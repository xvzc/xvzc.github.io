[{"categories":null,"content":"이번 포스트에서는 Docker를 활용하여 OpenVPN 서버를 구축하는 방법에 대해서 알아보겠습니다. 환경 변수 등록하기 export OVPN_DATA=\"/home/{username}/openvpn\" OpenVPN 설정 생성하기 docker run -v $OVPN_DATA:/etc/openvpn --rm kylemanna/openvpn ovpn_genconfig -u udp://{HOST} CA와 서버 Key 생성하기 passphrase 없이 생성하려면 마지막에 nopass 옵션 추가 docker run -v $OVPN_DATA:/etc/openvpn --rm -it kylemanna/openvpn ovpn_initpki OpenVPN 실행하기 docker run -v $OVPN_DATA:/etc/openvpn -d -p 1194:1194/udp --cap-add=NET_ADMIN kylemanna/openvpn 클라이언트 유저 생성하는 법 docker run -v $OVPN_DATA:/etc/openvpn --rm -it kylemanna/openvpn easyrsa build-client-full {USER_NAME} nopass ovpn 파일 생성하는 법 docker run -v $OVPN_DATA:/etc/openvpn --rm kylemanna/openvpn ovpn_getclient {USER_NAME}\u003e {USER_NAME}.ovpn 클라이언트 삭제하는 법 docker run --rm -it -v $OVPN_DATA:/etc/openvpn kylemanna/openvpn ovpn_revokeclient {USER_NAME} remove 설정 파일 여는 법 docker run -v $OVPN_DATA:/etc/openvpn --rm -it kylemanna/openvpn vi /etc/openvpn/openvpn.conf ... duplicate-cn # enable multiple connections with sigle cert max-clients 30 ### Route Configurations Below route 192.168.254.0 255.255.255.0 data ### Push Configurations Below #push \"block-outside-dns\" #push \"dhcp-option DNS 8.8.8.8\" #push \"dhcp-option DNS 8.8.4.4\" push \"comp-lzo no\" push \"route {VPC_CIDR} {SUBNET_MASK}\" # example of 10.1.0.0/16 # push \"route 10.1.0.0 255.255.0.0\" ","date":"2023-10-27","objectID":"/openvpn-docker/:0:0","tags":["docker"],"title":"Docker를 활용하여 OpenVPN 서버 실행하기","uri":"/openvpn-docker/"},{"categories":null,"content":"이번 포스트에서는 VPC 내부에서 Public API Gateway를 호출할 때 403 응답을 받는 이슈에 대해 알아보고, 해결방안을 알아보겠습니다. 문제 상황 MSA 환경에서 서비스 목적으로 Public regional API Gateway 를 사용하며, Micro services 간의 통신을 위해 별도의 Private API Gateway를 사용 중입니다. 인스턴스 또는 컨테이너 내부에서 Private API Gateway를 사용할 때는 VPC Endpoint를 통해 통신합니다. VPN에 연결된 상태에서 Public API Gateway를 호출하면 403 Forbidden Error 응답을 수신합니다. 원인 Route 53 레코드를 확인한 결과, API Gateway domain name이 CNAME 레코드로 등록되어있는 것을 확인할 수 있었습니다. AWS 문서 API Gateway에 대한 트래픽을 개인 도메인을 활용해서 라우팅 하는 방법에 의하면 커스텀 도메인에 대한 Route 53 레코드를 등록할 때 A 레코드를 사용하는 것을 권장하고있습니다. 해결 일반적으로 A 레코드는 IP 주소만을 입력할 수 있도록 되어있으나 Alias 옵션을 켜면 API Gateway 커스텀 도메인을 등록할 수 있습니다. 레코드 네임이 커스텀 도메인과 동일하지 않으면 레코드를 등록할 수 없습니다. ","date":"2023-03-19","objectID":"/aws-403-inside-vpc/:0:0","tags":["troubleshoot","aws"],"title":"AWS VPC 내부에서 Public Rest API Gateway 호출 시 403 Error 발생","uri":"/aws-403-inside-vpc/"},{"categories":null,"content":"테라폼으로 서로 다른 계정간 VPC Peering Connection을 맺을 때 Error: Unable to modify EC2 VPC Peering Connection Options라는 에러가 출력되는 경우가 있습니다. 이번 포스트에서는 해당 이슈의 원인과 해결 방안에 대해 알아보도록 하겠습니다. 문제 상황 Error: Unable to modify EC2 VPC Peering Connection Options. EC2 VPC Peering Connection(pcx-xxxxxxxxx) Please set the auto_accept attribute to true or activate the EC2 VPC Peering Connection manually. 원인 언뜻 보기엔 단순히 auto_accept 옵션을 true 로 할당하라는 안내 메시지인 것 같지만 서로 다른 계정 사이에서는 auto_accept 옵션이 동작하지않습니다. 조금 더 조사를 해본 결과 inner block인 accepter, requester block이 원인이였다는 것을 알 수 있었습니다. 해결 몇번의 apply 실패 과정을 통해 aws_vpc_peering_connection 에 최소한의 옵션만 남겨두고 다 지워보았습니다. resource \"aws_vpc_peering_connection\" \"to_owner\" { vpc_id = module.network.vpc.id peer_owner_id = owner.account_id peer_vpc_id = owner.vpc_id auto_accept = false # accepter { # allow_remote_vpc_dns_resolution = true # } # requester { # allow_remote_vpc_dns_resolution = true # } tags = { Name = \"vpc-peer-to-owner\" } } 이후 apply는 성공합니다. 문제가 발생하는 부분은 accepter, requester 설정이였습니다. 에러로그와 함께 생각해보면, aws_vpc_peering_connection 블럭은 내부적으로 connection을 생성한 뒤 accepter, requester 옵션을 변경하는 API를 호출한다고 추측할 수 있습니다. 따라서 ”Active 상태가 아닌 Peering에 대한 옵션 수정을 수행할 수 없다” 가 위 에러메시지의 정확한 의미라고 볼 수 있습니다. 문제가 발생한 부분은 아래와 같이 별도의 리소스 블럭으로 변경할 수 있습니다. resource \"aws_vpc_peering_connection_options\" \"to_owner\" { vpc_peering_connection_id = aws_vpc_peering_connection.to_owner.id accepter { allow_remote_vpc_dns_resolution = true } requester { allow_remote_vpc_dns_resolution = true } } 테라폼을 활용하여 서로 다른 계정간 Peering을 하기 위해선 다음과 같은 단계로 여러번에 나누어 apply를 해야합니다. 최소한의 설정으로 Peering Connection Request. Accepter 계정에서 Connection 수락. 라우팅 설정 및 dns resolution 설정. ","date":"2023-02-13","objectID":"/tf-vpc-peering-err/:0:0","tags":["terraform","aws","troubleshoot"],"title":"Terraform AWS 계정 간 VPC Peering 생성할 때 에러","uri":"/tf-vpc-peering-err/"},{"categories":null,"content":"terraform plan 을 실행했을 때 변경되지 않은 리소스에 대해 아래와 같은 메시지가 출력되는 현상을 겪었습니다. 이번 포스트에서는 해당 이슈의 원인과 해결 방안에 대해 알아보도록 하겠습니다. 문제 상황 Note: Objects have changed outside of Terraform ... 제가 겪은 이슈의 경우에는 보안 그룹 리소스에 대해 해당 메시지가 출력되었습니다. 원인 terraform 공식 문서에는 security group 리소스를 생성할 때 cidr_blocks 인자를 optional로 규정하고있습니다. 하지만 cidr_blocks 에 null 을 할당하게 되면, AWS 콘솔에서는 inbound rule이 존재하지 않는 것으로 확인되었습니다. 따라서 관리되고 있는 terraform state 가 실제 상태간에 차이점이 발생하게 되고, 테라폼이 관여하지 않은 변경사항이 발생한 것으로 인식되는 문제였습니다. 해결 cidr_bock 인자에 값을 할당해서 해결할 수 있었습니다. ","date":"2023-02-03","objectID":"/tf-object-changed-outside/:0:0","tags":["troubleshoot","terraform"],"title":"Terraform 경고 메시지 \"Objects have changed outside of Terraform\"","uri":"/tf-object-changed-outside/"},{"categories":null,"content":"이번 포스트에서는 AWS ECR에 도커 이미지를 Push 하는 방법에 대해서 알아봅시다. Install AWS CLI 우선 아래 링크를 참고하여 AWS CLI 를 설치합니다. Installing or updating the latest version of the AWS CLI AWS CLI 설정 AWS CLI에 계정정보를 설정하기 위해 다음 명령어를 실행하고 정보를 입력합니다. aws configure Command line output AWS Access Key ID [None]: IAM_AWS_ACCESS_KEY AWS Secret Access Key [None]: IAM_AWS_SECRET_KEY Default region name [None]: AWS_REGION_NAME Default output format [None]: json Login to Docker Docker CLI 에 로그인 하기위해 다음 명령어를 실행합니다. {aws_account_id} 는 ‘-’ 를 제외하고 숫자만을 입력해주세요 aws ecr get-login-password --region {aws_region} | docker login --username AWS --password-stdin {aws_account_id}.dkr.ecr.{aws_region}.amazonaws.com Command line output Login Succeeded Get the image id 먼저 아래 명령어를 통해 ECR에 push 하고자하는 이미지의 ID를 확인합니다. docker images Image Tag 추가 아래 명령어를 실행하여 해당 이미지의 태그를 설정합니다. ECR URI는 AWS Conolse → Amazon Elastic Container Registry → Repositories 에서 확인할 수 있습니다. docker tag {image_id} {ECR_URI}:{TAG} 이미지 Push 마지막으로 아래 명령어를 실행하여 ECR에 push 합니다. docker push {ECR_URI}:{TAG} ","date":"2022-12-27","objectID":"/aws-push-img-to-ecr/:0:0","tags":["aws"],"title":"AWS ECR에 도커 이미지를 올리는 방법","uri":"/aws-push-img-to-ecr/"},{"categories":null,"content":"일별 통계를 뽑아낼 때, 특정 날짜에 데이터가 존재하지 않는 경우 통계 데이터에서 해당 날짜가 비어있는 경우가있습니다. 다음 쿼리로 먼저 연속된 날짜를 SELECT해서 JOIN 하면 연속된 날짜로 만들어 줄 수 있습니다. with recursive calendar as ( select (select createdAt from Strategy where id = ?1 ) as createdAt union all select createdAt + interval 1 day as d from calendar where createdAt + interval 1 day \u003c now()) select * from calendar ","date":"2022-06-20","objectID":"/mysql-create-dates/:0:0","tags":["database","mysql"],"title":" MySQL 임의의 연속된 날짜 데이터 Select 하기","uri":"/mysql-create-dates/"},{"categories":null,"content":"코딩테스트 연습 - 체육복 ","date":"2022-04-21","objectID":"/prog-42862/:0:0","tags":["algorithm","cpp"],"title":"Programmers 체육복 C++","uri":"/prog-42862/"},{"categories":null,"content":"접근 방법 탐욕 알고리즘을 사용하여 해결해야합니다. 여분의 체육복을 가지고 온 경우를 O, 체육복이 없는 경우를 X인 경우를 배열로 나타내면 {O, X, O, X} 입니다. 이 때 3번째 학생이 2번째 학생에게 체육복을 빌려주게 되면 4번째 학생은 1번째 학생에게 체육복을 빌려줄 수 없게 됩니다. 따라서 앞에 있는 학생을 우선으로 빌려주어야만 그리디하게 문제를 해결할 수 있습니다. 여분의 체육복이 있는 학생도 체육복을 도난당할 수 있다는 점에 유의합니다. ","date":"2022-04-21","objectID":"/prog-42862/:1:0","tags":["algorithm","cpp"],"title":"Programmers 체육복 C++","uri":"/prog-42862/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e using namespace std; int solution(int n, vector\u003cint\u003e lost, vector\u003cint\u003e reserve) { int answer = 0; set\u003cint\u003e set_lost(lost.begin(), lost.end()); set\u003cint\u003e set_reserve(reserve.begin(), reserve.end()); vector\u003cint\u003e common; for (auto i : lost) { if (set_reserve.find(i) != set_reserve.end()) { common.push_back(i); } } for (auto i : common) { set_lost.erase(i); set_reserve.erase(i); } n -= set_lost.size(); for (auto i : set_reserve) { if (set_lost.find(i-1) != set_lost.end()) { set_lost.erase(i-1); set_lost.erase(i); n++; continue; } if (set_lost.find(i+1) != set_lost.end()) { set_lost.erase(i+1); set_lost.erase(i); n++; continue; } } return n; } ","date":"2022-04-21","objectID":"/prog-42862/:2:0","tags":["algorithm","cpp"],"title":"Programmers 체육복 C++","uri":"/prog-42862/"},{"categories":null,"content":"코딩테스트 연습 - 실패율 ","date":"2022-04-19","objectID":"/prog-42889/:0:0","tags":["algorithm","cpp"],"title":"Programmers 실패율 C++","uri":"/prog-42889/"},{"categories":null,"content":"접근 방법 스테이지에 도달한 유저의 수, 해당 스테이지를 아직까지 시도중인 유저의 수를 각각 다른 해시맵에 기록하고, 스테이지 별 실패율을 계산하여 vector\u003cpair\u003cint, double\u003e\u003e 에 저장합니다. 이 때 아무도 도달하지 못한 스테이지가 있다면 분모가 0이 되는 경우가 발생할 수 있으므로 예외처리를 해주어야합니다. 최종적으로 정렬함수를 정의하여 실패율이 높은 순서대로 정렬한 뒤 인덱스를 리턴합니다. ","date":"2022-04-19","objectID":"/prog-42889/:1:0","tags":["algorithm","cpp"],"title":"Programmers 실패율 C++","uri":"/prog-42889/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e using namespace std; bool comp(pair\u003cint, float\u003e p1, pair\u003cint, float\u003e p2) { if (p1.second \u003e p2.second) { return true; } if (p1.second == p2.second) { return p1.first \u003c p2.first; } return false; } vector\u003cint\u003e solution(int N, vector\u003cint\u003e stages) { vector\u003cint\u003e answer; unordered_map\u003cint, int\u003e trying; unordered_map\u003cint, int\u003e entered; for (auto s : stages) { trying[s]++; for (int i = 1; i \u003c= s; ++i) { entered[i]++; } } vector\u003cpair\u003cint, double\u003e\u003e v; for (int i = 1; i \u003c= N; ++i) { v.push_back({i, entered[i] == 0 ? 0 : ((double)trying[i]/entered[i])}); } sort(v.begin(), v.end(), comp); for (auto p : v) { answer.push_back(p.first); } return answer; } ","date":"2022-04-19","objectID":"/prog-42889/:2:0","tags":["algorithm","cpp"],"title":"Programmers 실패율 C++","uri":"/prog-42889/"},{"categories":null,"content":"코딩테스트 연습 - 모의고사 ","date":"2022-04-15","objectID":"/prog-42840/:0:0","tags":["algorithm","cpp"],"title":"Programmers 모의고사 C++","uri":"/prog-42840/"},{"categories":null,"content":"접근 방법 단순한 구현 문제입니다. 모듈로 연산을 활용하여 반복되는 패턴을 정답과 비교하여 맞은 문제의 수를 카운트합니다. ","date":"2022-04-15","objectID":"/prog-42840/:1:0","tags":["algorithm","cpp"],"title":"Programmers 모의고사 C++","uri":"/prog-42840/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e using namespace std; int strategy1[5] = {1,2,3,4,5}; int strategy2[8] = {2,1,2,3,2,4,2,5}; int strategy3[10] = {3,3,1,1,2,2,4,4,5,5}; vector\u003cint\u003e solution(vector\u003cint\u003e answers) { vector\u003cint\u003e answer; vector\u003cint\u003e persons = {0, 0, 0}; for (int i = 0; i \u003c answers.size(); ++i) { if(strategy1[i % 5] == answers[i]) { persons[0]++; } if(strategy2[i % 8] == answers[i]) { persons[1]++; } if(strategy3[i % 10] == answers[i]) { persons[2]++; } } int maxi = *max_element(persons.begin(), persons.end()); for (int i = 0; i \u003c persons.size(); ++i) { if (maxi == persons[i]) { answer.push_back(i+1); } } return answer; } ","date":"2022-04-15","objectID":"/prog-42840/:2:0","tags":["algorithm","cpp"],"title":"Programmers 모의고사 C++","uri":"/prog-42840/"},{"categories":null,"content":"코딩테스트 연습 - 없는 숫자 더하기 ","date":"2022-04-13","objectID":"/prog-86051/:0:0","tags":["algorithm","cpp"],"title":"Programmers 없는 숫자 더하기 C++","uri":"/prog-86051/"},{"categories":null,"content":"접근 방법 unordered_set\u003cint\u003e 자료구조에 0 ~ 9 까지의 정수를 넣고 numbers에 존재하는 모든 수를 지우고, 남은 값을 모두 더합니다. ","date":"2022-04-13","objectID":"/prog-86051/:1:0","tags":["algorithm","cpp"],"title":"Programmers 없는 숫자 더하기 C++","uri":"/prog-86051/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e using namespace std; int solution(vector\u003cint\u003e numbers) { int answer = 0; unordered_set\u003cint\u003e hset = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (auto i : numbers) { hset.erase(i); } for (auto i : hset) { answer += i; } return answer; } ","date":"2022-04-13","objectID":"/prog-86051/:2:0","tags":["algorithm","cpp"],"title":"Programmers 없는 숫자 더하기 C++","uri":"/prog-86051/"},{"categories":null,"content":"코딩테스트 연습 - K번째수 ","date":"2022-04-12","objectID":"/prog-42748/:0:0","tags":["algorithm","cpp"],"title":"Programmers K 번째 수 C++","uri":"/prog-42748/"},{"categories":null,"content":"접근 방법 단순히 sub vector를 추출하여 정렬한 뒤 인덱스를 넣어 해결할 수도 있지만, 우선순위 큐를 활용하는 방법으로 풀어보았습니다. ","date":"2022-04-12","objectID":"/prog-42748/:1:0","tags":["algorithm","cpp"],"title":"Programmers K 번째 수 C++","uri":"/prog-42748/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e using namespace std; vector\u003cint\u003e solution(vector\u003cint\u003e array, vector\u003cvector\u003cint\u003e\u003e commands) { vector\u003cint\u003e answer; for (auto v : commands) { int i = v[0]; int j = v[1]; int k = v[2]; vector\u003cint\u003e sub(array.begin()+i-1, array.begin()+j); priority_queue\u003cint\u003e pq; for (auto n : sub) { if (pq.size() \u003c k) { pq.push(n); continue; } if (pq.top() \u003e n) { pq.pop(); pq.push(n); } } answer.push_back(pq.top()); } return answer; } ","date":"2022-04-12","objectID":"/prog-42748/:2:0","tags":["algorithm","cpp"],"title":"Programmers K 번째 수 C++","uri":"/prog-42748/"},{"categories":null,"content":"코딩테스트 연습 - 완주하지 못한 선수 ","date":"2022-04-07","objectID":"/prog-42576/:0:0","tags":["algorithm","cpp"],"title":"Programmers 완주하지 못한 선수 C++","uri":"/prog-42576/"},{"categories":null,"content":"접근 방법 처음에는 unordered_set 을 사용하여 풀 수 있을 거라고 생각했지만 중복된 이름이 존재할 수 있기 때문에 unordered_map\u003cstring, int\u003e 자료구조를 사용하여 참가자 이름을 count하고, completion에 존재하는 이름들을 한명씩 빼는 방식으로 해결합니다. ","date":"2022-04-07","objectID":"/prog-42576/:1:0","tags":["algorithm","cpp"],"title":"Programmers 완주하지 못한 선수 C++","uri":"/prog-42576/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e using namespace std; string solution(vector\u003cstring\u003e participant, vector\u003cstring\u003e completion) { string answer = \"\"; unordered_map\u003cstring, int\u003e hmap; for (auto s : participant) { hmap[s]++; } for (auto s : completion) { hmap[s]--; } for (auto p : hmap) { if (p.second != 0) { answer = p.first; } } return answer; } ","date":"2022-04-07","objectID":"/prog-42576/:2:0","tags":["algorithm","cpp"],"title":"Programmers 완주하지 못한 선수 C++","uri":"/prog-42576/"},{"categories":null,"content":"코딩테스트 연습 - 소수 만들기 ","date":"2022-04-06","objectID":"/prog-12977/:0:0","tags":["algorithm","cpp"],"title":"Programmers 소수 만들기 C++","uri":"/prog-12977/"},{"categories":null,"content":"접근 방법 주어진 벡터에서 3개의 숫자를 중복되지 않게 선택할 수 있는 모든 경우의 수를 구하기 위한 루프를 돕니다. $O(N^3)$의 복잡도가 소요되며 입력된 벡터의 길이가 50개 이므로 충분한 시간내에 수행할 수 있습니다. 이후 3개의 숫자를 더한 값에 대해 $\\sqrt N$ 까지 나누어 보는 것으로 소수판정을 합니다. ","date":"2022-04-06","objectID":"/prog-12977/:1:0","tags":["algorithm","cpp"],"title":"Programmers 소수 만들기 C++","uri":"/prog-12977/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e using namespace std; bool check(int num) { for (int i = 2; i \u003c= sqrt(num); ++i) { if (num % i == 0) { return false; } } return true; } int solution(vector\u003cint\u003e nums) { int answer = 0; for (int i = 0; i \u003c nums.size(); ++i) { for (int j = i + 1; j \u003c nums.size(); ++j) { for (int k = j + 1; k \u003c nums.size(); ++k) { int sum = nums[i] + nums[j] + nums[k]; if (check(sum)) { answer++; } } } } return answer; } ","date":"2022-04-06","objectID":"/prog-12977/:2:0","tags":["algorithm","cpp"],"title":"Programmers 소수 만들기 C++","uri":"/prog-12977/"},{"categories":null,"content":"코딩테스트 연습 - 내적 ","date":"2022-04-04","objectID":"/prog-70128/:0:0","tags":["algorithm","cpp"],"title":"Programmers 내적 C++","uri":"/prog-70128/"},{"categories":null,"content":"접근 방법 주어진 조건 대로만 풀면 쉽게 해결할 수 있습니다. ","date":"2022-04-04","objectID":"/prog-70128/:1:0","tags":["algorithm","cpp"],"title":"Programmers 내적 C++","uri":"/prog-70128/"},{"categories":null,"content":"코드 #include \u003cstring\u003e #include \u003cvector\u003e using namespace std; int solution(vector\u003cint\u003e a, vector\u003cint\u003e b) { int answer = 0; for (int i = 0; i \u003c a.size(); ++i) { answer += a[i]*b[i]; } return answer; } ","date":"2022-04-04","objectID":"/prog-70128/:2:0","tags":["algorithm","cpp"],"title":"Programmers 내적 C++","uri":"/prog-70128/"},{"categories":null,"content":"코딩테스트 연습 - 로또의 최고 순위와 최저 순위 ","date":"2022-04-04","objectID":"/prog-77484/:0:0","tags":["algorithm","cpp"],"title":"Programmers 로또의 최고 순위와 최저 순위 C++","uri":"/prog-77484/"},{"categories":null,"content":"접근 방법 arr[i]는 i개의 번호가 맞았을 때 등수를 의미합니다. unordered_set에 win_nums를 저장하고 현재 가지고 있는 번호들 중 맞은 번호의 갯수와 0의 갯수를 카운트합니다. 가장 높은 등수의 경우는 현재 맞은 번호의 갯수 + 모든 0의 갯수, 가장 낮은 등수의 경우는 현재 맞은 번호의 갯수가 됩니다. ","date":"2022-04-04","objectID":"/prog-77484/:1:0","tags":["algorithm","cpp"],"title":"Programmers 로또의 최고 순위와 최저 순위 C++","uri":"/prog-77484/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e using namespace std; int arr[] = {6, 6, 5, 4, 3, 2, 1}; vector\u003cint\u003e solution(vector\u003cint\u003e lottos, vector\u003cint\u003e win_nums) { vector\u003cint\u003e answer; unordered_set\u003cint\u003e hset; for (auto i : win_nums) { hset.insert(i); } int count = 0; int zero = 0; for (auto i : lottos) { if (i == 0) { zero++; continue; } if (hset.find(i) != hset.end()) { count++; } } answer.push_back(arr[count+zero]); answer.push_back(arr[count]); return answer; } ","date":"2022-04-04","objectID":"/prog-77484/:2:0","tags":["algorithm","cpp"],"title":"Programmers 로또의 최고 순위와 최저 순위 C++","uri":"/prog-77484/"},{"categories":null,"content":"코딩테스트 연습 - 숫자 문자열과 영단어 ","date":"2022-04-04","objectID":"/prog-81301/:0:0","tags":["algorithm","cpp"],"title":"Programmers 숫자 문자열과 영단어 C++","uri":"/prog-81301/"},{"categories":null,"content":"접근 방법 c++의 regex_replace를 활용해서 쉽게 해결할 수 있습니다. ","date":"2022-04-04","objectID":"/prog-81301/:1:0","tags":["algorithm","cpp"],"title":"Programmers 숫자 문자열과 영단어 C++","uri":"/prog-81301/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e using namespace std; int solution(string s) { s = regex_replace(s, regex(\"zero\"), \"0\"); s = regex_replace(s, regex(\"one\"), \"1\"); s = regex_replace(s, regex(\"two\"), \"2\"); s = regex_replace(s, regex(\"three\"), \"3\"); s = regex_replace(s, regex(\"four\"), \"4\"); s = regex_replace(s, regex(\"five\"), \"5\"); s = regex_replace(s, regex(\"six\"), \"6\"); s = regex_replace(s, regex(\"seven\"), \"7\"); s = regex_replace(s, regex(\"eight\"), \"8\"); s = regex_replace(s, regex(\"nine\"), \"9\"); return stoi(s); } ","date":"2022-04-04","objectID":"/prog-81301/:2:0","tags":["algorithm","cpp"],"title":"Programmers 숫자 문자열과 영단어 C++","uri":"/prog-81301/"},{"categories":null,"content":"코딩테스트 연습 - 신고 결과 받기 ","date":"2022-04-04","objectID":"/prog-92334/:0:0","tags":["algorithm","cpp"],"title":"Programmers 신고 결과 받기 C++","uri":"/prog-92334/"},{"categories":null,"content":"접근 방법 ","date":"2022-04-04","objectID":"/prog-92334/:1:0","tags":["algorithm","cpp"],"title":"Programmers 신고 결과 받기 C++","uri":"/prog-92334/"},{"categories":null,"content":"필요한 자료구조 unordered_set\u003cstring\u003e v = 중복된 신고를 제거 unordered_map\u003cstring, vector\u003cstring\u003e\u003e k = 신고 당한 id v = 신고자 id 리스트 unordered_map\u003cstring, int\u003e k = 유저 id v = 메일을 받은 횟수 중복된 신고를 제거하고, report_record에 신고 현황을 저장합니다. 이후 report_record에 대한 루프를 돌면서 report_record[id].size() 가 k 보다 크다면 report_record[id]에 대한 루프를 돌면서 mail_count[report_record[id][i]]++ 를 합니다. ","date":"2022-04-04","objectID":"/prog-92334/:1:1","tags":["algorithm","cpp"],"title":"Programmers 신고 결과 받기 C++","uri":"/prog-92334/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define fi first #define se second using namespace std; pair\u003cstring, string\u003e split(string s) { stringstream ss(s); string from, to; ss \u003e\u003e from; ss \u003e\u003e to; return {from, to}; } vector\u003cint\u003e solution(vector\u003cstring\u003e id_list, vector\u003cstring\u003e report, int k) { vector\u003cint\u003e answer; unordered_map\u003cstring, vector\u003cstring\u003e\u003e report_record; unordered_map\u003cstring, int\u003e mail_count; unordered_set\u003cstring\u003e set_report; for (auto r : report) { set_report.insert(r); } for (auto r : set_report) { pair\u003cstring, string\u003e p = split(r); report_record[p.se].push_back(p.fi); } for (auto record : report_record) { vector\u003cstring\u003e reporters = record.se; if (reporters.size() \u003c k) { continue; } for (auto r : reporters) { mail_count[r]++; } } for (auto id : id_list) { answer.push_back(mail_count[id]); } return answer; } ","date":"2022-04-04","objectID":"/prog-92334/:2:0","tags":["algorithm","cpp"],"title":"Programmers 신고 결과 받기 C++","uri":"/prog-92334/"},{"categories":null,"content":"코딩테스트 연습 - 신규 아이디 추천 ","date":"2022-04-04","objectID":"/prog-72410/:0:0","tags":["algorithm","cpp"],"title":"Programmers 신규 아이디 추천 C++","uri":"/prog-72410/"},{"categories":null,"content":"접근 방법 복잡해 보일 수 있지만 차근차근 한단계 씩 해나가면 간단히 해결할 수 있는 문제입니다. c++의 regex를 활용하면 조금 더 수월하게 풀 수 있습니다. ","date":"2022-04-04","objectID":"/prog-72410/:1:0","tags":["algorithm","cpp"],"title":"Programmers 신규 아이디 추천 C++","uri":"/prog-72410/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e using namespace std; string solution(string new_id) { string step1; for (auto c : new_id) { step1 += tolower(c); } cout \u003c\u003c \"step1 : \" \u003c\u003c step1 \u003c\u003c endl; string step2; for (auto c : step1) { if ('a' \u003c= c and c \u003c= 'z') { step2 += c; continue; } if ('0' \u003c= c and c \u003c= '9') { step2 += c; continue; } if (c == '-' or c == '_' or c == '.') { step2 += c; } } cout \u003c\u003c \"step2 : \" \u003c\u003c step2 \u003c\u003c endl; string step3 = regex_replace(step2, regex(\"[.]+\"), \".\"); cout \u003c\u003c \"step3 : \" \u003c\u003c step3 \u003c\u003c endl; string step4 = regex_replace(step3, regex(\"^[.]|[.]$\"), \"\"); cout \u003c\u003c \"step4 : \" \u003c\u003c step4 \u003c\u003c endl; string step5 = step4; if (step5 == \"\") { step5 = \"a\"; } string step6 = step5; if (step6.length() \u003e= 16) { step6 = step6.substr(0, 15); step6 = regex_replace(step6, regex(\"[.]$\"), \"\"); } string step7 = step6; if (step7.length() \u003c= 2) { while (step7.length() != 3) { step7.push_back(step7.back()); } } return step7; } ","date":"2022-04-04","objectID":"/prog-72410/:2:0","tags":["algorithm","cpp"],"title":"Programmers 신규 아이디 추천 C++","uri":"/prog-72410/"},{"categories":null,"content":"코딩테스트 연습 - 음양 더하기 ","date":"2022-04-04","objectID":"/prog-76501/:0:0","tags":["algorithm","cpp"],"title":"Programmers 음양 더하기 C++","uri":"/prog-76501/"},{"categories":null,"content":"접근 방법 단순한 문제입니다. signs의 값이 true라면 양수를, false 라면 음수를 더해줍니다. ","date":"2022-04-04","objectID":"/prog-76501/:1:0","tags":["algorithm","cpp"],"title":"Programmers 음양 더하기 C++","uri":"/prog-76501/"},{"categories":null,"content":"코드 #include \u003cstring\u003e #include \u003cvector\u003e using namespace std; int solution(vector\u003cint\u003e absolutes, vector\u003cbool\u003e signs) { int answer = 0; for (int i = 0; i \u003c signs.size(); ++i) { answer += signs[i] ? absolutes[i] : -absolutes[i]; } return answer; } ","date":"2022-04-04","objectID":"/prog-76501/:2:0","tags":["algorithm","cpp"],"title":"Programmers 음양 더하기 C++","uri":"/prog-76501/"},{"categories":null,"content":"코딩테스트 연습 - 크레인 인형뽑기 게임 ","date":"2022-04-04","objectID":"/prog-64061/:0:0","tags":["algorithm","cpp"],"title":"Programmers 크레인 인형뽑기 게임 C++","uri":"/prog-64061/"},{"categories":null,"content":"접근 방법 Stack 자료구조를 활용해서 쉽게 해결할 수 있습니다. 입력으로 주어진 moves 배열의 컬럼 값이 1부터 시작한다는 점에 유의합니다. ","date":"2022-04-04","objectID":"/prog-64061/:1:0","tags":["algorithm","cpp"],"title":"Programmers 크레인 인형뽑기 게임 C++","uri":"/prog-64061/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e using namespace std; int solution(vector\u003cvector\u003cint\u003e\u003e board, vector\u003cint\u003e moves) { int answer = 0; stack\u003cint\u003e stk; for (auto col : moves) { int target = 0; for (int i = 0; i \u003c board.size(); ++i) { if (board[i][col-1]) { target = board[i][col-1]; board[i][col-1] = 0; break; } } if (target == 0) { continue; } if (!stk.empty() and stk.top() == target) { stk.pop(); answer += 2; continue; } stk.push(target); } return answer; } ","date":"2022-04-04","objectID":"/prog-64061/:2:0","tags":["algorithm","cpp"],"title":"Programmers 크레인 인형뽑기 게임 C++","uri":"/prog-64061/"},{"categories":null,"content":"코딩테스트 연습 - 키패드 누르기 ","date":"2022-04-04","objectID":"/prog-67256/:0:0","tags":["algorithm","cpp"],"title":"Programmers 키패드 누르기 C++","uri":"/prog-67256/"},{"categories":null,"content":"접근 방법 unordered_map\u003cint, pair\u003cint, int\u003e\u003e 를 활용해 번호를 키 값으로 키 패드의 좌표를 얻어낼 수 있는 자료구조를 만들었습니다. 이후 주어진 조건에 맞게 조건 분기를 해결합니다. ","date":"2022-04-04","objectID":"/prog-67256/:1:0","tags":["algorithm","cpp"],"title":"Programmers 키패드 누르기 C++","uri":"/prog-67256/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define fi first #define se second using namespace std; string solution(vector\u003cint\u003e numbers, string hand) { unordered_map\u003cint, pair\u003cint, int\u003e\u003e keypad = { {1, {0, 0}}, {2, {0, 1}}, {3, {0, 2}}, {4, {1, 0}}, {5, {1, 1}}, {6, {1, 2}}, {7, {2, 0}}, {8, {2, 1}}, {9, {2, 2}}, {10, {3, 0}}, {0, {3, 1}}, {11, {3, 2}} }; pair\u003cint, int\u003e left = keypad[10]; pair\u003cint ,int\u003e right = keypad[11]; string answer = \"\"; for (auto num : numbers) { if (num == 1 or num == 4 or num == 7) { left = keypad[num]; answer += \"L\"; continue; } if (num == 3 or num == 6 or num == 9) { right = keypad[num]; answer += \"R\"; continue; } pair\u003cint ,int\u003e target = keypad[num]; int dl = abs(left.fi - target.fi) + abs(left.se - target.se); int dr = abs(right.fi - target.fi) + abs(right.se - target.se); if (dl \u003c dr) { left = keypad[num]; answer += \"L\"; continue; } if (dr \u003c dl) { right = keypad[num]; answer += \"R\"; continue; } if (dr == dl) { if (hand == \"left\") { left = keypad[num]; answer += \"L\"; } else { right = keypad[num]; answer += \"R\"; } continue; } } return answer; } ","date":"2022-04-04","objectID":"/prog-67256/:2:0","tags":["algorithm","cpp"],"title":"Programmers 키패드 누르기 C++","uri":"/prog-67256/"},{"categories":null,"content":"3135번: 라디오 ","date":"2022-03-28","objectID":"/boj-3135/:0:0","tags":["algorithm","cpp"],"title":"BOJ 3135 해설 C++","uri":"/boj-3135/"},{"categories":null,"content":"접근 방법 즐겨찾기에 등록되어있는 주파수 중 목적지 주파수와 가장 가까운 위치에 있는 주파수를 $K$라 할 때, $K$ 를 경유하여 B에 도달하기 까지 눌러야하는 버튼의 횟수는 $abs(K - B) + 1$ 입니다. 다만, 즐겨찾기에 등록되어있는 모든 주파수로 부터 B 까지의 거리가 $abs(A - B)$ 보다 큰 경우가 있을 수 있다는 것을 고려하면, 정답은 $min(abs(B - A), abs(B - K))$ 라는 사실을 알 수 있습니다. ","date":"2022-03-28","objectID":"/boj-3135/:1:0","tags":["algorithm","cpp"],"title":"BOJ 3135 해설 C++","uri":"/boj-3135/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define debug if constexpr (local) std::cout #define endl '\\\\n' #define fi first #define se second #define all(x) x.begin(),x.end() #ifdef LOCAL constexpr bool local = true; #else constexpr bool local = false; #endif typedef long long ll; typedef unsigned long long ull; using namespace std; int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); if constexpr (local) (void)!freopen(\"input.txt\", \"r\", stdin); int A, B, N; cin \u003e\u003e A \u003e\u003e B \u003e\u003e N; vector\u003cint\u003e v(N); for (int i = 0; i \u003c N; ++i) { cin \u003e\u003e v[i]; } int closest = INT_MAX; for (auto i : v) { int cur = abs(closest - B); int nxt = abs(i - B); if (nxt \u003c cur) { closest = i; } } cout \u003c\u003c min(abs(B - A), abs(B - closest) + 1) \u003c\u003c endl; return 0; ","date":"2022-03-28","objectID":"/boj-3135/:2:0","tags":["algorithm","cpp"],"title":"BOJ 3135 해설 C++","uri":"/boj-3135/"},{"categories":null,"content":"1051번: 숫자 정사각형 ","date":"2022-03-15","objectID":"/boj-1051/:0:0","tags":["algorithm","cpp"],"title":"BOJ 1051 해설 C++","uri":"/boj-1051/"},{"categories":null,"content":"접근 방법 단순 구현 문제입니다. size를 늘려가며 $O(N^3)$ 으로 완전탐색합니다. ","date":"2022-03-15","objectID":"/boj-1051/:1:0","tags":["algorithm","cpp"],"title":"BOJ 1051 해설 C++","uri":"/boj-1051/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define debug if constexpr (local) std::cout #define endl '\\\\n' #define fi first #define se second #define all(x) x.begin(),x.end() #ifdef LOCAL constexpr bool local = true; #else constexpr bool local = false; #endif typedef long long ll; typedef unsigned long long ull; using namespace std; /* - GLOBAL VARIABLES ---------------------------- */ int N, M; /* ----------------------------------------------- */ /* - FUNCTIONS ----------------------------------- */ bool is_out_of_index(int i, int j, int size) { return i + size \u003e= N || j + size \u003e= M; } /* ----------------------------------------------- */ int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); if constexpr (local) (void)!freopen(\"input.txt\", \"r\", stdin); cin \u003e\u003e N \u003e\u003e M; vector\u003cstring\u003e v(N); for (int i = 0; i \u003c N; ++i) { cin \u003e\u003e v[i]; } int answer = 0; for (int size = 0; size \u003c min(N, M); ++size) { for (int i = 0; i \u003c N; ++i) { for (int j = 0; j \u003c M; ++j) { if (is_out_of_index(i, j, size)) { continue; } if (v[i][j] == v[i+size][j] \u0026\u0026 v[i][j+size] == v[i+size][j+size] \u0026\u0026 v[i][j] == v[i][j+size]) { answer = max(answer, (size + 1)*(size + 1)); } } } } cout \u003c\u003c answer; return 0; } ","date":"2022-03-15","objectID":"/boj-1051/:2:0","tags":["algorithm","cpp"],"title":"BOJ 1051 해설 C++","uri":"/boj-1051/"},{"categories":null,"content":"2056번: 작업 ","date":"2022-03-14","objectID":"/boj-2056/:0:0","tags":["algorithm","cpp"],"title":"BOJ 2056 해설 C++","uri":"/boj-2056/"},{"categories":null,"content":"접근 방법 위상 정렬을 하면서 해당 작업을 완료하기 위해 필요한 총 시간을 업데이트 하면서 $total$ 배열을 채워나갑니다.$total[i]$ 는 i 번째 작업을 완료하기 위해 필요한 총 시간이며, 완성된 배열에서의 최댓값이 모든 작업을 완료하기위해 최소한으로 필요한 시간입니다 ","date":"2022-03-14","objectID":"/boj-2056/:1:0","tags":["algorithm","cpp"],"title":"BOJ 2056 해설 C++","uri":"/boj-2056/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define debug if constexpr (local) std::cout #define endl '\\\\n' #define fi first #define se second #define all(x) x.begin(),x.end() #ifdef LOCAL constexpr bool local = true; #else constexpr bool local = false; #endif typedef long long ll; typedef unsigned long long ull; using namespace std; /* - GLOBAL VARIABLES ---------------------------- */ int N; int indeg[10001]; int times[10001]; vector\u003cint\u003e jobs[10001]; /* ----------------------------------------------- */ int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); if constexpr (local) (void)!freopen(\"input.txt\", \"r\", stdin); cin \u003e\u003e N; for (int i = 1; i \u003c= N; ++i) { cin \u003e\u003e times[i]; int num; cin \u003e\u003e num; for (int j = 0; j \u003c num; ++j) { int x; cin \u003e\u003e x; jobs[x].push_back(i); indeg[i]++; } } vector\u003cint\u003e total(N + 1); queue\u003cint\u003e q; for (int i = 1; i \u003c= N ; ++i) { if (indeg[i] == 0) { q.push(i); total[i] = times[i]; } } while(!q.empty()) { int cur = q.front(); q.pop(); for (auto next : jobs[cur]) { if (--indeg[next] == 0) { q.push(next); } total[next] = max(total[next], total[cur] + times[next]); } } cout \u003c\u003c *max_element(all(total)); return 0; } ","date":"2022-03-14","objectID":"/boj-2056/:2:0","tags":["algorithm","cpp"],"title":"BOJ 2056 해설 C++","uri":"/boj-2056/"},{"categories":null,"content":"2637번: 장난감 조립 ","date":"2022-03-14","objectID":"/boj-2637/:0:0","tags":["algorithm","cpp"],"title":"BOJ 2637 해설 C++","uri":"/boj-2637/"},{"categories":null,"content":"접근 방법 위상 정렬을 하면서 $i$ 부품으로 $j$ 부품을 만들 때 소요되는 $i$의 갯수를 다이나믹프로그래밍을 활용하여 구합니다. 현재 바라보고 있는 $cnt[i][cur]$이 0이 아니라면 $i$ 부품으로 $cur$ 부품을 만들었다는 의미이므로, $cur[i][next]$ = $cur[i][next]$ + $cur[i][cur]*need$ 라는 식을 얻을 수 있습니다. $need$는 $next$ 부품을 만들기 위해 필요한 $cur$의 갯수를 의미합니다. ","date":"2022-03-14","objectID":"/boj-2637/:1:0","tags":["algorithm","cpp"],"title":"BOJ 2637 해설 C++","uri":"/boj-2637/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define debug if constexpr (local) std::cout #define endl '\\\\n' #define fi first #define se second #ifdef LOCAL constexpr bool local = true; #else constexpr bool local = false; #endif typedef long long ll; typedef unsigned long long ull; using namespace std; /* - GLOBAL VARIABLES ---------------------------- */ int cnt[101][101]; int indeg[101]; vector\u003cpair\u003cint, int\u003e\u003e parts[101]; /* ----------------------------------------------- */ int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); if constexpr (local) (void)!freopen(\"input.txt\", \"r\", stdin); int N, M; cin \u003e\u003e N \u003e\u003e M; while (M--) { int x, y, z; cin \u003e\u003e x \u003e\u003e y \u003e\u003e z; // x 부품을 만들기 위해 필요한 y의 갯수는 z개 parts[y].push_back({x, z}); indeg[x]++; } queue\u003cint\u003e q; for (int i = 1; i \u003c= N; ++i) { if (indeg[i] == 0) { q.push(i); cnt[i][i] = 1; } } while (!q.empty()) { int cur = q.front(); q.pop(); for (auto p : parts[cur]) { int next = p.fi; int need = p.se; if (--indeg[next] == 0) { q.push(next); } for (int i = 1; i \u003c= N; ++i) { if (cnt[i][cur]) { cnt[i][next] += cnt[i][cur]*need; } } } } for (int i = 1; i \u003c= N; ++i) { if (cnt[i][i]) { cout \u003c\u003c i \u003c\u003c ' ' \u003c\u003c cnt[i][N] \u003c\u003c endl; } } return 0; } ","date":"2022-03-14","objectID":"/boj-2637/:2:0","tags":["algorithm","cpp"],"title":"BOJ 2637 해설 C++","uri":"/boj-2637/"},{"categories":null,"content":"11689번: GCD(n, k) = 1 ","date":"2022-02-06","objectID":"/boj-11689/:0:0","tags":["algorithm","cpp"],"title":"BOJ 11689 해설 C++","uri":"/boj-11689/"},{"categories":null,"content":"접근 방법 $n$ 보다 작거나 같으면서 $gcd(n, k)$를 만족하는 모든 자연수는 $n$ 보다 같거나 작으면서 $n$과 서로소인 자연수의 개수와 같습니다. 즉 오일러 함수를 사용해서 $\\phi(n)$을 구하는 문제가 되겠습니다. 오일러 함수에는 몇가지 규칙이 있는데 그 중에서도 이 문제에서 우리가 사용할 규칙은 다음과 같습니다. $\\phi(p^a) = p^{a} - p^{a-1}$ $\\phi(mn) = \\phi(m)\\phi(n)$ 풀이에 대해 간략하게 설명을 하겠습니다. 우선 에라토스테네스의 체 알고리즘을 사용해서 $\\sqrt{n}$ 까지의 모든 소수를 구합니다. 최악의 경우 $n = 10^{12}$ 이 입력으로 들어오면 1,000,000 까지의 소수를 구하므로 시간적으로 충분합니다. 그 다음으로, 구해진 소수를 하나씩 확인하면서 해당 $n$이 현재 바라보고 있는 소수로 더이상 나누어 떨어지지 않을 때 까지 다음을 반복합니다. a = 0; p = prime[i] while(n % p == 0) { n /= p; a++; } 위 과정을 한번 반복하면 $n$은 $p^{a}$ 라는 소인수를 갖고 있다는 사실을 알 수 있습니다. 따라서 위 오일러 함수 1번 규칙을 사용해서 값을 얻어낼 수 있습니다. 이러한 과정을 반복하면서 위에서 언급된 2번 규칙에 따라 answer 변수에 $\\phi(p^a)$의 값을 곱하면 해를 얻을 수 있습니다. ","date":"2022-02-06","objectID":"/boj-11689/:1:0","tags":["algorithm","cpp"],"title":"BOJ 11689 해설 C++","uri":"/boj-11689/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define debug if constexpr (local) std::cout #define endl '\\\\n' #define fi first #define se second #define MAX 1000001 #ifdef LOCAL constexpr bool local = true; #else constexpr bool local = false; #endif typedef long long ll; typedef unsigned long long ull; using namespace std; /* - GLOBAL VARIABLES ---------------------------- */ ll N; bool is_prime[MAX]; /* ----------------------------------------------- */ /* - FUNCTIONS ----------------------------------- */ ll exponent(int p, int a) { ll ret = 1; for (int i = 0; i \u003c a; ++i) { ret *= p; } return ret; } ll totient(ll p, ll a) { return exponent(p, a-1)*(p - 1); } /* ----------------------------------------------- */ int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); if constexpr (local) (void)!freopen(\"input.txt\", \"r\", stdin); cin \u003e\u003e N; memset(is_prime, true, sizeof(is_prime)); is_prime[0] = false; is_prime[1] = false; for (int i = 2; i*i \u003c MAX; ++i) { if (!is_prime[i]) { continue; } for (int j = i*i; j \u003c MAX; j+=i) { is_prime[j] = false; } } if (2 \u003c= N \u0026\u0026 N \u003c MAX \u0026\u0026 is_prime[N]) { cout \u003c\u003c N - 1 \u003c\u003c endl; return 0; } ll answer = 1; for (ll i = 2; i*i \u003c= N; ++i) { if (!is_prime[i]) { continue; } ll prime = i; ll n = 0; while (N % prime == 0) { n++; N /= prime; } if (n \u003e= 1) { answer *= totient(prime, n); } } if (N \u003e 1) { answer *= N-1; } cout \u003c\u003c answer \u003c\u003c endl; return 0; } ","date":"2022-02-06","objectID":"/boj-11689/:2:0","tags":["algorithm","cpp"],"title":"BOJ 11689 해설 C++","uri":"/boj-11689/"},{"categories":null,"content":"1238번: 파티 ","date":"2022-01-22","objectID":"/boj-1238/:0:0","tags":["algorithm","cpp"],"title":"BOJ 1238 해설 C++","uri":"/boj-1238/"},{"categories":null,"content":"접근 방법 다익스트라 알고리즘을 활용해서 모든 노드에 대해 다익스트라를 수행합니다. i 번째 학생이 X의 집으로 파티를 가는 경우의 왕복 거리는 distance[i][X] + distance[X][i] 가 됩니다. ","date":"2022-01-22","objectID":"/boj-1238/:1:0","tags":["algorithm","cpp"],"title":"BOJ 1238 해설 C++","uri":"/boj-1238/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define debug if constexpr (local) std::cout #define endl '\\\\n' #define fi first #define se second #ifdef LOCAL constexpr bool local = true; #else constexpr bool local = false; #endif typedef long long ll; typedef unsigned long long ull; using namespace std; /* - GLOBAL VARIABLES ---------------------------- */ vector\u003cpair\u003cint, int\u003e\u003e edges[10001]; int N, M, X, dist[1001][1001]; /* ----------------------------------------------- */ /* - FUNCTIONS ----------------------------------- */ void clear_dist() { for (int i = 0; i \u003c 1001; ++i) { for (int j = 0; j \u003c 1001; ++j) { dist[i][j] = INT_MAX; } } } void dijkstra(int start) { priority_queue\u003cpair\u003cint, int\u003e\u003e pq; dist[start][start] = 0; pq.push({dist[start][start], start}); while(!pq.empty()) { int dist_to_cur = -pq.top().fi; int cur_idx = pq.top().se; pq.pop(); if (dist_to_cur \u003e dist[start][cur_idx]) { continue; } for (int i = 0; i \u003c edges[cur_idx].size(); ++i) { int dist_to_next = dist_to_cur + edges[cur_idx][i].se; int next_idx = edges[cur_idx][i].fi; if (dist_to_next \u003c dist[start][next_idx]) { dist[start][next_idx] = dist_to_next; pq.push({-dist_to_next, next_idx}); } } } } /* ----------------------------------------------- */ int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); if constexpr (local) (void)!freopen(\"input.txt\", \"r\", stdin); cin \u003e\u003e N \u003e\u003e M \u003e\u003e X; int start, end, price; while(M--) { cin \u003e\u003e start \u003e\u003e end \u003e\u003e price; edges[start].push_back({end, price}); } clear_dist(); for (int i = 1 ; i \u003c= N; ++i) { dijkstra(i); } int max_dist = INT_MIN; int round_trip = INT_MIN; for (int i = 1; i \u003c= N; ++i) { round_trip = dist[i][X] + dist[X][i]; if(round_trip \u003e max_dist) { max_dist = round_trip; } } cout \u003c\u003c max_dist \u003c\u003c endl; return 0; } ","date":"2022-01-22","objectID":"/boj-1238/:2:0","tags":["algorithm","cpp"],"title":"BOJ 1238 해설 C++","uri":"/boj-1238/"},{"categories":null,"content":"1062번: 가르침 비트마스킹 풀이 ","date":"2021-12-07","objectID":"/boj-1062/:0:0","tags":["algorithm","cpp"],"title":"BOJ 1062 해설 C++","uri":"/boj-1062/"},{"categories":null,"content":"접근 방법 선택할 글자, 그리고 확인하고자 하는 단어들을 모두 비트로 표현하면 해당 단어가 선택된 글자들에 포함되는지 여부는 \u0026(and) 연산으로 빠르게 확인할 수 있습니다. 예를 들면 필수 문자들인 “antatica” 를 포함하는 비트는 다음과 같이 구할 수 있습니다. 중복된 알파벳은 생략할 수 있습니다. 아래 $antatica$변수는 “antatica”를 표현하기위해 필요한 최소한의 문자를 비트로 표현한 것이기 때문입니다. int antatica = 0; antatica |= 1 \u003c\u003c ('a' - 'a'); antatica |= 1 \u003c\u003c ('a' - 'n'); antatica |= 1 \u003c\u003c ('a' - 't'); antatica |= 1 \u003c\u003c ('a' - 'i'); antatica |= 1 \u003c\u003c ('a' - 'c'); // antatica = 532741 위와 같은 방법으로 주어진 단어들도 모두 비트로 표현해줍니다. 이후 과정은 \u0026(and) 연산을 이용해서 쉽게 해결할 수 있게됩니다. 이후 $i \u003c (1 « 26)$ 범위까지 반복문을 돌면 가르칠 수 있는 단어의 모든 부분집합을 순회할 수 있고, $i$ \u0026 $word$ == $word$ 인 경우를 카운트 해줍니다. 또한, 켜져있는 비트의 갯수, 필수 글자들의 포함 여부를 체크해 불필요한 연산을 줄여주면 더욱 효율적으로 풀 수 있습니다. ","date":"2021-12-07","objectID":"/boj-1062/:1:0","tags":["algorithm","cpp"],"title":"BOJ 1062 해설 C++","uri":"/boj-1062/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define debug if constexpr (local) std::cout #define endl '\\\\n' #define fi first #define se second #ifdef LOCAL constexpr bool local = true; #else constexpr bool local = false; #endif using namespace std; int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); if constexpr (local) (void)!freopen(\"input.txt\", \"r\", stdin); const int antatica = 532741; int n, k; cin \u003e\u003e n \u003e\u003e k; vector\u003cint\u003e v(n); string temp; for(int i = 0; i \u003c n; ++i) { cin \u003e\u003e temp; int bits = antatica; for(auto c : temp) bits |= 1 \u003c\u003c ((int)c - 'a'); v[i] = bits; } int answer = 0; for(unsigned int i = 0; i \u003c (1 \u003c\u003c 26); ++i) { if((i \u0026 antatica) != antatica) continue; if(__builtin_popcount(i) != k) continue; int cnt = 0; for(auto word_bits : v) { if((i \u0026 word_bits) == word_bits) cnt++; } answer = cnt \u003e answer ? cnt : answer; } cout \u003c\u003c answer \u003c\u003c endl; return 0; } 백트래킹 풀이 ","date":"2021-12-07","objectID":"/boj-1062/:2:0","tags":["algorithm","cpp"],"title":"BOJ 1062 해설 C++","uri":"/boj-1062/"},{"categories":null,"content":"접근 방법 $learned[i]$는 i 번째 알파벳을 배웠는지의 여부를 나타냅니다. 예를들어 $learned[0]$이 true 라면 ‘a’ 알파벳을 배웠다는 의미입니다 $learned[]$ 배열에 대해 배울 수 있는 모든 경우의 수에 대해 백트래킹을 수행하며 배운 알파벳의 갯수가 K개가 되면 우선 해당 경우가 정답일 가능성이 있는지를 체크한 뒤 읽을 수 있는 단어의 수를 카운트합니다. 입력되는 단어는 반드시 “anta”로 시작하며 “tica”로 끝나기 때문에 “antatica”를 모두 배우지 않은 경우는 카운트하지 않습니다. #include \u003cbits/stdc++.h\u003e #define debug if constexpr (local) std::cout #define endl '\\\\n' #define fi first #define se second #define all(x) x.begin(),x.end() #ifdef LOCAL constexpr bool local = true; #else constexpr bool local = false; #endif typedef long long ll; typedef unsigned long long ull; using namespace std; /* - GLOBAL VARIABLES ---------------------------- */ int N, K; bool word[50][26]; bool learned[26]; int answer = 0; /* ----------------------------------------------- */ /* - FUNCTIONS ----------------------------------- */ int count() { int cnt = 0; for (int i = 0; i \u003c N; ++i) { for (int j = 0; j \u003c 26; ++j) { if (!learned[j] \u0026\u0026 word[i][j]) { cnt--; break; } } cnt++; } return cnt; } bool is_promising() { if (!learned['a'-'a']) return false; if (!learned['n'-'a']) return false; if (!learned['t'-'a']) return false; if (!learned['i'-'a']) return false; if (!learned['c'-'a']) return false; return true; } void gogosing(int idx, int cnt) { if (cnt == K) { if(!is_promising()) { return; } answer = max(answer, count()); return; } for (int i = idx+1; i \u003c 26; ++i) { learned[i] = true; gogosing(i, cnt + 1); learned[i] = false; } } /* ----------------------------------------------- */ int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); if constexpr (local) (void)!freopen(\"input.txt\", \"r\", stdin); cin \u003e\u003e N \u003e\u003e K; string temp; for (int i = 0; i \u003c N ; ++i) { cin \u003e\u003e temp; for (auto c : temp) { word[i][c - 'a'] = true; } } for (int i = 0; i \u003c 26; ++i) { learned[i] = true; gogosing(i, 1); learned[i] = false; } cout \u003c\u003c answer; return 0; } ","date":"2021-12-07","objectID":"/boj-1062/:3:0","tags":["algorithm","cpp"],"title":"BOJ 1062 해설 C++","uri":"/boj-1062/"},{"categories":null,"content":"20210번: 파일 탐색기 ","date":"2021-12-07","objectID":"/boj-20210/:0:0","tags":["algorithm","cpp"],"title":"BOJ 20210 해설 C++","uri":"/boj-20210/"},{"categories":null,"content":"접근 방법 정렬 조건을 결정하는 함수를 구현하는게 까다로운 문제입니다. 우선 주어진 문자열들을 알파벳 하나로 이루어진 문자열과, 숫자로만 이루어진 문자열로 tokenize하고, 문자 하나하나를 비교하는 함수를 작성해주시며 됩니다. 다루어야하는 경우는 다음과 같이 네가지가 있습니다. 알파벳 vs 알파벳 : 문제에서 주어진 조건 (AaBbCcDdEe….Zz) 순으로 정렬합니다. 알파벳 vs 숫자 : 숫자가 우선입니다. 숫자 vs 알파벳 : 숫자가 우선입니다. 숫자 vs 숫자 : 숫자로 이루어진 문자열의 정수 값이 작은 것이 우선이며, 선행하는 0이 존재한다면 0의 갯수가 적은 것이 우선입니다. 다만 문제에 주어진 조건과 같이 숫자가 $2^{64}$ 을 넘을 수 있기 때문에 문자열로 처리해 주어야합니다. ","date":"2021-12-07","objectID":"/boj-20210/:1:0","tags":["algorithm","cpp"],"title":"BOJ 20210 해설 C++","uri":"/boj-20210/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define debug if constexpr (local) std::cout #define endl '\\\\n' #define fi first #define se second #ifdef LOCAL constexpr bool local = true; #else constexpr bool local = false; #endif typedef long long ll; typedef unsigned long long ull; using namespace std; /***************************************************************/ vector\u003cstring\u003e tokenize(string s) { vector\u003cstring\u003e v; string temp = \"\"; for(auto c : s) { if( c \u003c '0' || '9' \u003c c ){ if(!temp.empty()) { v.push_back(temp); temp.clear(); } string s; s.push_back(c); v.push_back(s); continue; } temp.push_back(c); } if(!temp.empty()) v.push_back(temp); return v; } bool is_number(char c) { return '0' \u003c= c \u0026\u0026 c \u003c= '9'; } bool is_charactor(char c) { return c \u003c '0' || '9' \u003c c; } int count_leading_zero(string s) { int ret = 0; for(auto c : s) { if(c != '0') break; ret++; } return ret; } string remove_leading_zero(string s) { int i = 0; for(; i \u003c s.length(); ++i) { if(s[i] == '0') continue; break; } if(i == s.length()) return \"0\"; return s.substr(i); } int compare_strnum(string s1, string s2) { if(s1.length() != s2.length()) { if(s1.length() \u003c s2.length()) return 1; else return -1; } for(int i = 0; i \u003c s1.length(); ++i) { if(s1[i] == s2[i]) continue; if(s1[i] - '0' \u003c s2[i] - '0') return 1; else return -1; } return 0; } bool compare_charactor(char c1, char c2) { string s1, s2; if(c1 == c2) return false; else { if(tolower(c1) == tolower(c2)) return c1 \u003c c2; else return tolower(c1) \u003c tolower(c2); } return false; } bool sorting(vector\u003cstring\u003e v1, vector\u003cstring\u003e v2) { for(int i = 0; i \u003c min(v1.size(), v2.size()); ++i) { char v1_first = v1[i][0]; char v2_first = v2[i][0]; if( is_charactor(v1_first) \u0026\u0026 is_charactor(v2_first) ) { if(v1_first == v2_first) continue; else return compare_charactor(v1_first, v2_first); } else if( is_number(v1_first) \u0026\u0026 is_charactor(v2_first) ) return true; else if( is_charactor(v1_first) \u0026\u0026 is_number(v2_first) ) return false; // ELSE string num1 = remove_leading_zero(v1[i]); string num2 = remove_leading_zero(v2[i]); int compare_result = compare_strnum(num1, num2); if(compare_result == 1) return true; if(compare_result == -1) return false; int count_leading_zero_v1 = count_leading_zero(v1[i]); int count_leading_zero_v2 = count_leading_zero(v2[i]); if(count_leading_zero_v1 \u003c count_leading_zero_v2) return true; else if(count_leading_zero_v1 \u003e count_leading_zero_v2) return false; else continue; } return v1.size() \u003c v2.size(); } /***************************************************************/ int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); if constexpr (local) (void)!freopen(\"input.txt\", \"r\", stdin); int n; cin \u003e\u003e n; vector\u003cvector\u003cstring\u003e\u003e v; string temp; while(n--) { cin \u003e\u003e temp; v.push_back(tokenize(temp)); } sort(v.begin(), v.end(), sorting); for(auto vs : v) { for(auto s : vs) { cout \u003c\u003c s; } cout \u003c\u003c endl; } return 0; } ","date":"2021-12-07","objectID":"/boj-20210/:2:0","tags":["algorithm","cpp"],"title":"BOJ 20210 해설 C++","uri":"/boj-20210/"},{"categories":null,"content":"2667번: 단지번호붙이기 ","date":"2021-11-24","objectID":"/boj-2667/:0:0","tags":["algorithm","cpp"],"title":"BOJ 2667 해설 C++","uri":"/boj-2667/"},{"categories":null,"content":"접근 방법 전체 2차원 벡터을 순회하면서 값이 0인 경우는 건너 뛰고, 값이 1인 경우에만 BFS를 수행합니다. 방문 처리는 별도의 2차원 벡터를 두지 않고 2차원 벡터의 값을 0으로 치환하는 방법을 사용합니다. ","date":"2021-11-24","objectID":"/boj-2667/:1:0","tags":["algorithm","cpp"],"title":"BOJ 2667 해설 C++","uri":"/boj-2667/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define debug if constexpr (local) std::cout #define endl '\\\\n' #define fi first #define se second #ifdef LOCAL constexpr bool local = true; #else constexpr bool local = false; #endif typedef long long ll; typedef unsigned long long ull; using namespace std; /* - GLOBAL VARIABLES ---------------------------- */ int n; int dx[4] = {-1, 0, 0, 1}; int dy[4] = { 0, -1, 1, 0}; /* ----------------------------------------------- */ /* - FUNCTIONS ----------------------------------- */ bool is_out_of_index(int y, int x) { return y \u003c 0 || y \u003e= n || x \u003c 0 || x \u003e= n; } /* ----------------------------------------------- */ int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); if constexpr (local) (void)!freopen(\"input.txt\", \"r\", stdin); cin \u003e\u003e n; vector\u003cvector\u003cint\u003e\u003e v(n); vector\u003cint\u003e answer; string temp; for (int i = 0; i \u003c n; ++i) { cin \u003e\u003e temp; for (int j = 0; j \u003c n; ++j) v[i].push_back(temp[j] - '0'); } queue\u003cpair\u003cint, int\u003e\u003e q; for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c n; ++j) { if(v[i][j] == 0) continue; int cnt = 0; q.push({i, j}); v[i][j] = 0; cnt++; while (!q.empty()) { int y = q.front().fi; int x = q.front().se; for (int k = 0; k \u003c 4; ++k) { int ny = y + dy[k]; int nx = x + dx[k]; if (is_out_of_index(ny, nx)) continue; if(v[ny][nx] == 0) continue; q.push({ny, nx}); v[ny][nx] = 0; cnt++; } q.pop(); } answer.push_back(cnt); } } sort(answer.begin(), answer.end()); cout \u003c\u003c answer.size() \u003c\u003c endl; for (int i = 0; i \u003c answer.size(); ++i) { cout \u003c\u003c answer[i] \u003c\u003c endl; } return 0; } ","date":"2021-11-24","objectID":"/boj-2667/:2:0","tags":["algorithm","cpp"],"title":"BOJ 2667 해설 C++","uri":"/boj-2667/"},{"categories":null,"content":"5525번: IOIOI ","date":"2021-11-24","objectID":"/boj-5525/:0:0","tags":["algorithm","cpp"],"title":"BOJ 5525 해설 C++","uri":"/boj-5525/"},{"categories":null,"content":"접근 방법 처음에는 $O(N^2)$ 풀이로 접근하였으나 서브테스크에서 시간초과가 되었습니다. 다음과 같은 규칙을 생각하면 $O(N)$ 으로 해결할 수 있습니다. $P = IOIOI$ $when$ $M = IOI$, $count = 0$ $when$ $M= IOIOI$, $count = 1$ $when$ $M = IOIOIOI$, $count = 2$ 위와 같이 현재 보고 있는 IOI 문자열의 길이가 P의 길이와 같아지는 지점 부터는 길이가 늘어남에 따라 count 가 1씩 증가하게됩니다. 이와 같은 규칙을 이용한다면, IOI 부분 문자열들의 길이만으로 모든 경우의 수를 계산할 수 있게됩니다. ","date":"2021-11-24","objectID":"/boj-5525/:1:0","tags":["algorithm","cpp"],"title":"BOJ 5525 해설 C++","uri":"/boj-5525/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define debug if constexpr (local) std::cout #define endl '\\\\n' #define fi first #define se second #ifdef LOCAL constexpr bool local = true; #else constexpr bool local = false; #endif typedef long long ll; typedef unsigned long long ull; using namespace std; /* - GLOBAL VARIABLES ---------------------------- */ int DP[1000001] = {0, }; /* ----------------------------------------------- */ int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); if constexpr (local) (void)!freopen(\"input.txt\", \"r\", stdin); int n, m; cin \u003e\u003e n \u003e\u003e m; string p, s; cin \u003e\u003e s; int answer = 0, length = 0; for (int i = 0; i \u003c= m - 2; ++i) { if(s[i] == 'O') { continue; } else { if(s[i + 1] == 'O' \u0026\u0026 s[i + 2] == 'I') { ++i; ++length; if(length \u003e= n) answer++; } else { length = 0; } } } cout \u003c\u003c answer \u003c\u003c endl; return 0; } ","date":"2021-11-24","objectID":"/boj-5525/:2:0","tags":["algorithm","cpp"],"title":"BOJ 5525 해설 C++","uri":"/boj-5525/"},{"categories":null,"content":"11279번: 최대 힙 ","date":"2021-11-18","objectID":"/boj-11279/:0:0","tags":["algorithm","cpp"],"title":"BOJ 11279 해설 C++","uri":"/boj-11279/"},{"categories":null,"content":"접근 방법 간단합니다. Heap을 구현하는 priority_queue 를 사용해서 쉽게 풀 수 있습니다. Heap 자료구조는 삽입, 삭제 연산이 발생할 때 마다 $O(logN)$ 복잡도를 갖는 정렬을 수행하므로, 최종 복잡도는 $O(NlogN)$ 입니다. ","date":"2021-11-18","objectID":"/boj-11279/:1:0","tags":["algorithm","cpp"],"title":"BOJ 11279 해설 C++","uri":"/boj-11279/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define debug if constexpr (local) std::cout #define endl '\\\\n' #define fi first #define se second #ifdef LOCAL constexpr bool local = true; #else constexpr bool local = false; #endif typedef long long ll; typedef unsigned long long ull; using namespace std; int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); if constexpr (local) (void)!freopen(\"input.txt\", \"r\", stdin); int N; cin \u003e\u003e N; priority_queue\u003cint, vector\u003cint\u003e, less\u003cint\u003e\u003e pq; int temp; for(int i = 0; i \u003c N; ++i) { cin \u003e\u003e temp; if(temp == 0) { if(pq.empty()) cout \u003c\u003c 0 \u003c\u003c endl; else { cout \u003c\u003c pq.top() \u003c\u003c endl; pq.pop(); } continue; } pq.push(temp); } return 0; } ","date":"2021-11-18","objectID":"/boj-11279/:2:0","tags":["algorithm","cpp"],"title":"BOJ 11279 해설 C++","uri":"/boj-11279/"},{"categories":null,"content":"11723번: 집합 ","date":"2021-11-18","objectID":"/boj-11723/:0:0","tags":["algorithm","cpp"],"title":"BOJ 11723 해설 C++","uri":"/boj-11723/"},{"categories":null,"content":"접근 방법 c++의 set은 이진 탐색 트리를 사용합니다. 따라서 탐색에 걸리는 시간이 $O(logN)$ 입니다. 입력의 갯수 3,000,000에 대해 $O(NlogN)$ 은 충분한 시간 복잡도 이므로, set을 사용하여 해결하면 되겠습니다. ","date":"2021-11-18","objectID":"/boj-11723/:1:0","tags":["algorithm","cpp"],"title":"BOJ 11723 해설 C++","uri":"/boj-11723/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define debug if constexpr (local) std::cout #define endl '\\\\n' #define fi first #define se second #ifdef LOCAL constexpr bool local = true; #else constexpr bool local = false; #endif typedef long long ll; typedef unsigned long long ull; using namespace std; /* - GLOBAL VARIABLES ---------------------------- */ /* ----------------------------------------------- */ /* - FUNCTIONS ----------------------------------- */ string set_to_string(set\u003cint\u003e s) { string result = \"{\"; for(auto i : s) { result+=to_string(i); result+=\", \"; } return result.substr(0, result.length()-2) + \"}\"; } /* ----------------------------------------------- */ int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); if constexpr (local) (void)!freopen(\"input.txt\", \"r\", stdin); int M; cin \u003e\u003e M; set\u003cint\u003e all = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20}; set\u003cint\u003e s; string op; int value; for(int i = 0; i \u003c M; ++i) { cin \u003e\u003e op; if(op == \"all\") { s = all; continue; } if(op == \"empty\") { s.clear(); continue; } cin \u003e\u003e value; if(op == \"add\") { if(0 \u003c= value \u0026\u0026 value \u003c= 20) s.insert(value); continue; } if(op == \"remove\") { if(0 \u003c= value \u0026\u0026 value \u003c= 20) s.erase(value); continue; } if(op == \"check\") { set\u003cint\u003e::iterator it = s.find(value); if(it == s.end()) cout \u003c\u003c 0 \u003c\u003c endl; else cout \u003c\u003c 1 \u003c\u003c endl; continue; } if(op == \"toggle\") { if(s.find(value) != s.end()) s.erase(value); else s.insert(value); continue; } } return 0; } ","date":"2021-11-18","objectID":"/boj-11723/:2:0","tags":["algorithm","cpp"],"title":"BOJ 11723 해설 C++","uri":"/boj-11723/"},{"categories":null,"content":"7576번: 토마토 ","date":"2021-11-18","objectID":"/boj-7516/:0:0","tags":["algorithm","cpp"],"title":"BOJ 7576 해설 C++","uri":"/boj-7516/"},{"categories":null,"content":"접근 방법 2차원 벡터 값 하나에 토마토가 익을 때 까지 걸린 시간을 기록하는 방법으로 풀 수 있습니다. 주변 토마토 값 = 부모 토마토 값 + 1 을 하면 2차원 벡터 내의 최댓값이 최종 상태까지 걸린 날짜가 됩니다. ","date":"2021-11-18","objectID":"/boj-7516/:1:0","tags":["algorithm","cpp"],"title":"BOJ 7576 해설 C++","uri":"/boj-7516/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define debug if constexpr (local) std::cout #define endl '\\\\n' #define fi first #define se second #ifdef LOCAL constexpr bool local = true; #else constexpr bool local = false; #endif typedef long long ll; typedef unsigned long long ull; using namespace std; /* - GLOBAL VARIABLES ---------------------------- */ int N, M; int dx[4] = { 0, -1, 1, 0}; int dy[4] = {-1, 0, 0, 1}; /* ----------------------------------------------- */ /* - FUNCTIONS ----------------------------------- */ bool is_out_of_index(int i, int j) { if(i \u003c 0 || N \u003c= i) return true; if(j \u003c 0 || M \u003c= j) return true; return false; } /* ----------------------------------------------- */ int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); if constexpr (local) (void)!freopen(\"input.txt\", \"r\", stdin); cin \u003e\u003e M \u003e\u003e N; // 입력을 받고 box내 값이 1인 경우 큐에 넣습니다. queue\u003cpair\u003cint, int\u003e\u003e q; vector\u003cvector\u003cint\u003e\u003e box(N, vector\u003cint\u003e(M, 0)); for(int i = 0; i \u003c N; ++i) { for(int j = 0; j \u003c M; ++j) { cin \u003e\u003e box[i][j]; if(box[i][j] == 1) q.push({i, j}); } } while(!q.empty()) { int y = q.front().fi; int x = q.front().se; // 상, 하, 좌, 우에 대한 반복문 for(int i = 0; i \u003c 4; ++i) { int ny = y + dy[i]; int nx = x + dx[i]; if(is_out_of_index(ny, nx)) continue; // 이미 익은 토마토이거나, 빈칸이라면 건너 뜁니다. if(box[ny][nx] != 0) continue; // 주변 토마토들을 부모토마토의 소요 날짜 + 1로 채웁니다. q.push({ny, nx}); box[ny][nx] = box[y][x] + 1; } q.pop(); } int result = -1e9; for(int i = 0; i \u003c N; ++i) { for(int j = 0; j \u003c M; ++j) { // 값이 0인 칸이 하나라도 존재하면 -1을 출력합니다. if(box[i][j] == 0) { cout \u003c\u003c -1 \u003c\u003c endl; return 0; } result = max(box[i][j], result); } } // 소요된 날짜 출력 cout \u003c\u003c result - 1 \u003c\u003c endl; return 0; } ","date":"2021-11-18","objectID":"/boj-7516/:2:0","tags":["algorithm","cpp"],"title":"BOJ 7576 해설 C++","uri":"/boj-7516/"},{"categories":null,"content":"11057번: 오르막 수 ","date":"2021-11-14","objectID":"/boj-11057/:0:0","tags":["algorithm","cpp"],"title":"BOJ 11057 해설 C++","uri":"/boj-11057/"},{"categories":null,"content":"접근 방법 2차원 적으로 접근해보겠습니다. arr[i][j] 는 길이가 i이고 j로 끝나는 숫자의 갯수를 의미합니다. 아래와 같이 표를 그려보면 arr[i][j] = arr[i-1][j] + arr[i][j-1] 이라는 점화식을 유도해 낼 수 있습니다. $\\def\\arraystretch{1.4}\\begin{array}{|l|l|l|l|l|l|l|l|l|l|l|}\\hline\\textsf{\\textbf{\\ \\}} \u0026 \\textsf{\\textbf{0}} \u0026 \\textsf{\\textbf{1}} \u0026 \\textsf{\\textbf{2}} \u0026 \\textsf{\\textbf{3}} \u0026 \\textsf{\\textbf{4}} \u0026 \\textsf{\\textbf{5}} \u0026 \\textsf{\\textbf{6}} \u0026 \\textsf{\\textbf{7}} \u0026 \\textsf{\\textbf{8}} \u0026 \\textsf{\\textbf{9}}\\\\hline\\textsf{0} \u0026 \\textsf{0} \u0026 \\textsf{0} \u0026 \\textsf{0} \u0026 \\textsf{0} \u0026 \\textsf{0} \u0026 \\textsf{0} \u0026 \\textsf{0} \u0026 \\textsf{0} \u0026 \\textsf{0} \u0026 \\textsf{0}\\\\hline\\textsf{1} \u0026 \\textsf{1\\ } \u0026 \\textsf{1\\ } \u0026 \\textsf{1} \u0026 \\textsf{1} \u0026 \\textsf{1} \u0026 \\textsf{1} \u0026 \\textsf{1} \u0026 \\textsf{1} \u0026 \\textsf{1} \u0026 \\textsf{1}\\\\hline\\textsf{2} \u0026 \\textsf{1} \u0026 \\textsf{2} \u0026 \\textsf{3} \u0026 \\textsf{4} \u0026 \\textsf{5} \u0026 \\textsf{6} \u0026 \\textsf{7} \u0026 \\textsf{8} \u0026 \\textsf{9} \u0026 \\textsf{10}\\\\hline\\textsf{3} \u0026 \\textsf{1} \u0026 \\textsf{3} \u0026 \\textsf{6} \u0026 \\textsf{10} \u0026 \\textsf{15} \u0026 \\textsf{21} \u0026 \\textsf{28} \u0026 \\textsf{36} \u0026 \\textsf{45} \u0026 \\textsf{55}\\\\hline\\textsf{…} \u0026 \\textsf{} \u0026 \\textsf{} \u0026 \\textsf{} \u0026 \\textsf{} \u0026 \\textsf{} \u0026 \\textsf{} \u0026 \\textsf{} \u0026 \\textsf{} \u0026 \\textsf{} \u0026 \\textsf{}\\\\hline\\textsf{1000} \u0026 \\textsf{} \u0026 \\textsf{} \u0026 \\textsf{} \u0026 \\textsf{} \u0026 \\textsf{} \u0026 \\textsf{} \u0026 \\textsf{} \u0026 \\textsf{} \u0026 \\textsf{} \u0026 \\textsf{}\\\\hline\\end{array}$ ","date":"2021-11-14","objectID":"/boj-11057/:1:0","tags":["algorithm","cpp"],"title":"BOJ 11057 해설 C++","uri":"/boj-11057/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define endl '\\\\n' #define fi first #define se second typedef long long ll; typedef unsigned long long ull; using namespace std; /* - GLOBAL VARIABLES ---------------------------- */ int DP[1001][11]; /* ----------------------------------------------- */ #define SUBMIT int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); #ifndef SUBMIT (void)!freopen(\"input.txt\", \"r\", stdin); cout \u003c\u003c \"# From the test case\" \u003c\u003c endl; #endif int N; cin \u003e\u003e N; int mod = 10007; for(int i = 1; i \u003c= 1000; ++i) { int sum = 1; DP[i][0] = 1; for(int j = 1; j \u003c= 9; ++j) { DP[i][j] = ((DP[i-1][j] % mod) + (DP[i][j-1] % mod)) % mod; sum = ((sum % mod) + (DP[i][j] % mod)) % mod; } DP[i][10] = sum; } cout \u003c\u003c DP[N][10] \u003c\u003c endl; return 0; } ","date":"2021-11-14","objectID":"/boj-11057/:2:0","tags":["algorithm","cpp"],"title":"BOJ 11057 해설 C++","uri":"/boj-11057/"},{"categories":null,"content":"1927번: 최소 힙 ","date":"2021-11-14","objectID":"/boj-1927/:0:0","tags":["algorithm","cpp"],"title":"BOJ 1927 해설 C++","uri":"/boj-1927/"},{"categories":null,"content":"접근 방법 입력 값이 들어올 때마다 최소한의 시간안에 정렬을 할 수 있는 자료구조인 힙을 사용합니다. C++ STL의 priority_queue를 사용하면 쉽게 해결할 수 있습니다. ","date":"2021-11-14","objectID":"/boj-1927/:1:0","tags":["algorithm","cpp"],"title":"BOJ 1927 해설 C++","uri":"/boj-1927/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define endl '\\\\n' #define fi first #define se second typedef long long ll; typedef unsigned long long ull; using namespace std; #define SUBMIT int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); #ifndef SUBMIT (void)!freopen(\"input.txt\", \"r\", stdin); cout \u003c\u003c \"# From the test case\" \u003c\u003c endl; #endif priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e pq; int x, n; cin \u003e\u003e n; for(int i = 0; i \u003c n; ++i) { cin \u003e\u003e x; if(x) pq.push(x); if(!x) { if(pq.empty()) { cout \u003c\u003c 0 \u003c\u003c endl; continue; } cout \u003c\u003c pq.top() \u003c\u003c endl; pq.pop(); } } return 0; } ","date":"2021-11-14","objectID":"/boj-1927/:2:0","tags":["algorithm","cpp"],"title":"BOJ 1927 해설 C++","uri":"/boj-1927/"},{"categories":null,"content":"2042번: 구간 합 구하기 ","date":"2021-11-14","objectID":"/boj-2042/:0:0","tags":["algorithm","cpp"],"title":"BOJ 2042 해설 C++","uri":"/boj-2042/"},{"categories":null,"content":"접근 방법 누적합을 이용하여 풀 수도 있다고 생각했었지만, 그렇게 풀게 되면 값을 바꾸는 연산이 존재하기 때문에 $O(N^2)$ 이 되어 TLE를 맞이하게 됩니다.. 따라서 세그먼트 트리를 사용해 update및 query를 $O(logN)$ 으로 해결합니다. ","date":"2021-11-14","objectID":"/boj-2042/:1:0","tags":["algorithm","cpp"],"title":"BOJ 2042 해설 C++","uri":"/boj-2042/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define endl '\\\\n' #define fi first #define se second typedef long long ll; typedef unsigned long long ull; using namespace std; /* - GLOBAL VARIABLES ---------------------------- */ vector\u003cll\u003e segment_tree; int x; /* ----------------------------------------------- */ /* - FUNCTIONS ----------------------------------- */ void update(int idx, ll value) { idx += x-1; segment_tree[idx] = value; idx/=2; while(idx \u003e 0) { segment_tree[idx] = segment_tree[idx*2] + segment_tree[idx*2 + 1]; idx/=2; } } ll query(int left, int right) { left+=x-1; right+=x-1; ll sum = 0; while(left \u003c= right) { if(left%2 == 1) { sum+=segment_tree[left]; } if(right%2 == 0) { sum+=segment_tree[right]; } right = (right-1)/2; left = (left+1)/2; } return sum; } /* ----------------------------------------------- */ #define SUBMIT int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); #ifndef SUBMIT (void)!freopen(\"input.txt\", \"r\", stdin); cout \u003c\u003c \"# From the test case\" \u003c\u003c endl; #endif int N, M, K; cin \u003e\u003e N \u003e\u003e M \u003e\u003e K; segment_tree = vector\u003cll\u003e(4 * N, 0); for(x = 1; x \u003c N; x*=2); for(int i = x; i \u003c x + N; ++i) cin \u003e\u003e segment_tree[i]; for(int i = x-1; i \u003e 0; --i) { segment_tree[i] = segment_tree[2*i] + segment_tree[2*i +1]; } ll a, b, c; for(int i = 0; i \u003c M + K; ++i) { cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; if(a == 1) { // update update(b, c); continue; } if(a == 2) { // query cout \u003c\u003c query(b, c) \u003c\u003c endl; continue; } } return 0; } ","date":"2021-11-14","objectID":"/boj-2042/:2:0","tags":["algorithm","cpp"],"title":"BOJ 2042 해설 C++","uri":"/boj-2042/"},{"categories":null,"content":"2357번: 최솟값과 최댓값 ","date":"2021-11-14","objectID":"/boj-2357/:0:0","tags":["algorithm","cpp"],"title":"BOJ 2357 해설 C++","uri":"/boj-2357/"},{"categories":null,"content":"접근 방법 구간합 세그먼트 트리를 약간 바꾸어 생각해서, 부모는 자식의 합을 저장하는 것이 아닌 최댓값과 최솟값을 저장하도록 구현하여 해결할 수 있습니다. ","date":"2021-11-14","objectID":"/boj-2357/:1:0","tags":["algorithm","cpp"],"title":"BOJ 2357 해설 C++","uri":"/boj-2357/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define endl '\\\\n' #define fi first #define se second typedef long long ll; typedef unsigned long long ull; using namespace std; /* - GLOBAL VARIABLES ---------------------------- */ int x; vector\u003cint\u003e max_seg, min_seg; /* ----------------------------------------------- */ /* - FUNCTIONS ----------------------------------- */ int query_max(int l, int r) { l+=x-1; r+=x-1; int value = 0; while(l \u003c= r) { if(l%2 == 1) { value = max(max_seg[l], value); } if(r%2 == 0) { value = max(max_seg[r], value); } l = (l+1)/2; r = (r-1)/2; } return value; } int query_min(int l, int r) { l+=x-1; r+=x-1; int value = INT_MAX; while(l \u003c= r) { if(l%2 == 1) { value = min(min_seg[l], value); } if(r%2 == 0) { value = min(min_seg[r], value); } l = (l+1)/2; r = (r-1)/2; } return value; } /* ----------------------------------------------- */ #define SUBMIT int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); #ifndef SUBMIT (void)!freopen(\"input.txt\", \"r\", stdin); cout \u003c\u003c \"# From the test case\" \u003c\u003c endl; #endif int N, M; cin \u003e\u003e N \u003e\u003e M; max_seg = vector\u003cint\u003e(4 * N, 0); min_seg = vector\u003cint\u003e(4 * N, INT_MAX); for(x = 1; x \u003c= N; x*=2); int temp; for(int i = x; i \u003c x + N; ++i) { cin \u003e\u003e temp; max_seg[i] = temp; min_seg[i] = temp; } for(int i = x-1; i \u003e 0; --i) { max_seg[i] = max(max_seg[i*2], max_seg[i*2 + 1]); min_seg[i] = min(min_seg[i*2], min_seg[i*2 + 1]); } int a, b; for(int i = 0; i \u003c M; ++i) { cin \u003e\u003e a \u003e\u003e b; cout \u003c\u003c query_min(a, b) \u003c\u003c ' ' \u003c\u003c query_max(a, b) \u003c\u003c endl; } return 0; } ","date":"2021-11-14","objectID":"/boj-2357/:2:0","tags":["algorithm","cpp"],"title":"BOJ 2357 해설 C++","uri":"/boj-2357/"},{"categories":null,"content":"2606번: 바이러스 ","date":"2021-11-14","objectID":"/boj-2606/:0:0","tags":["algorithm","cpp"],"title":"BOJ 2606 해설 C++","uri":"/boj-2606/"},{"categories":null,"content":"접근 방법 1번 컴퓨터가 바이러스에 감염되었을 때 연쇄적으로 감염되는 컴퓨터의 수를 구하는 문제입니다. 따라서 최초 큐에 1번 컴퓨터의 인덱스를 넣고 시작하는 BFS를 구현합니다. 답의 갯수에서는 1번 컴퓨터를 제외하고 출력해야하는 점을 생각하고 구현해주시면 되겠습니다. ","date":"2021-11-14","objectID":"/boj-2606/:1:0","tags":["algorithm","cpp"],"title":"BOJ 2606 해설 C++","uri":"/boj-2606/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define SUBMIT #define debug if constexpr (!submit) std::cout #define endl '\\\\n' #define fi first #define se second #ifdef SUBMIT constexpr bool submit = true; #else constexpr bool submit = false; #endif using namespace std; /* - GLOBAL VARIABLES ---------------------------- */ bool visited[101] = {false, }; /* ----------------------------------------------- */ int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); if constexpr (!submit) { (void)!freopen(\"input.txt\", \"r\", stdin); cout \u003c\u003c \"# From the test case\" \u003c\u003c endl; } int n, m; cin \u003e\u003e n \u003e\u003e m; vector\u003cvector\u003cint\u003e\u003e v(n+1); int x, y; for(int i = 0; i \u003c m; ++i) { cin \u003e\u003e x \u003e\u003e y; v[x].push_back(y); v[y].push_back(x); } queue\u003cint\u003e q; int answer = 0; q.push(1); visited[1] = true; while(!q.empty()) { for(int i = 0; i \u003c v[q.front()].size(); ++i) { if(visited[v[q.front()][i]]) continue; q.push(v[q.front()][i]); visited[v[q.front()][i]] = true; answer++; } debug \u003c\u003c q.front() \u003c\u003c endl; q.pop(); } cout \u003c\u003c answer \u003c\u003c endl; return 0; } ","date":"2021-11-14","objectID":"/boj-2606/:2:0","tags":["algorithm","cpp"],"title":"BOJ 2606 해설 C++","uri":"/boj-2606/"},{"categories":null,"content":"1389번: 케빈 베이컨의 6단계 법칙 ","date":"2021-11-07","objectID":"/boj-1389/:0:0","tags":["algorithm","cpp"],"title":"BOJ 1389 해설 C++","uri":"/boj-1389/"},{"categories":null,"content":"접근 방법 최단 경로 알고리즘을 사용하는 방법도 있지만, 부모 노드의 depth를 기억하고 자식노드에게 증가된 값을 부여하는 방식의 너비 우선 탐색으로 접근했습니다. 친구 관계는 중복되어 주어질 수 있으므로 노드간의 관계는 set을 사용해서 구현하였습니다. ","date":"2021-11-07","objectID":"/boj-1389/:1:0","tags":["algorithm","cpp"],"title":"BOJ 1389 해설 C++","uri":"/boj-1389/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define endl '\\\\n' #define fi first #define se second using namespace std; #define SUBMIT int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); #ifndef SUBMIT (void)!freopen(\"input.txt\", \"r\", stdin); cout \u003c\u003c \"# From the test case\" \u003c\u003c endl; #endif int n, m; cin \u003e\u003e n \u003e\u003e m; vector\u003cset\u003cint\u003e\u003e v(n+1); int x, y; for(int i = 0; i \u003c m; i++) { cin \u003e\u003e x \u003e\u003e y; v[x].insert(y); v[y].insert(x); } pair\u003cint, int\u003e answer = {INT_MAX, INT_MAX}; for(int i = 1; i \u003c v.size(); ++i) { vector\u003cbool\u003e visited(n+1, false); queue\u003cpair\u003cint, int\u003e\u003e q; int kevin_bacon = 0; q.push({i, 0}); visited[i] = true; kevin_bacon += q.front().se; while(!q.empty()) { for(auto n : v[q.front().fi]) { if(!visited[n]) { q.push({n, q.front().se + 1}); visited[n] = true; } } kevin_bacon += q.front().se; q.pop(); } if(answer.se \u003e kevin_bacon) answer = {i, kevin_bacon}; } cout \u003c\u003c answer.fi \u003c\u003c endl;; return 0; } ","date":"2021-11-07","objectID":"/boj-1389/:2:0","tags":["algorithm","cpp"],"title":"BOJ 1389 해설 C++","uri":"/boj-1389/"},{"categories":null,"content":"1697번: 숨바꼭질 ","date":"2021-11-07","objectID":"/boj-1697/:0:0","tags":["algorithm","cpp"],"title":"BOJ 1697 해설 C++","uri":"/boj-1697/"},{"categories":null,"content":"접근 방법 $X-1$, $X + 1$, $2X$로 가는 경우들을 생각해서 BFS를 해줍니다. $N$의 최대, 최소 범위를 넘지 않도록 고려해야합니다. ","date":"2021-11-07","objectID":"/boj-1697/:1:0","tags":["algorithm","cpp"],"title":"BOJ 1697 해설 C++","uri":"/boj-1697/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define endl '\\\\n' #define fi first #define se second using namespace std; #define SUBMIT int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); #ifndef SUBMIT (void)!freopen(\"input.txt\", \"r\", stdin); cout \u003c\u003c \"# From the test case\" \u003c\u003c endl; #endif int n, k; cin \u003e\u003e n \u003e\u003e k; queue\u003cpair\u003cint, int\u003e\u003e q; vector\u003cbool\u003e visited(100001, false); q.push({n, 0}); visited[n] = true; int answer = 0; while(!q.empty()) { if(q.front().fi == k) { answer = q.front().se; break; } if(q.front().fi - 1 \u003e= 0) { if(!visited[q.front().fi - 1]) { q.push({q.front().fi - 1, q.front().se + 1}); visited[q.front().fi] = true; } } if(q.front().fi + 1 \u003c= 100000) { if(!visited[q.front().fi + 1]) { q.push({q.front().fi + 1, q.front().se + 1}); visited[q.front().fi] = true; } } if(q.front().fi * 2 \u003c= 100000) { if(!visited[q.front().fi * 2]) { q.push({q.front().fi * 2, q.front().se + 1}); visited[q.front().fi] = true; } } q.pop(); } cout \u003c\u003c answer \u003c\u003c endl; return 0; } ","date":"2021-11-07","objectID":"/boj-1697/:2:0","tags":["algorithm","cpp"],"title":"BOJ 1697 해설 C++","uri":"/boj-1697/"},{"categories":null,"content":"1107번: 리모컨 ","date":"2021-11-06","objectID":"/boj-1107/:0:0","tags":["algorithm","cpp"],"title":"BOJ 1107 해설 C++","uri":"/boj-1107/"},{"categories":null,"content":"접근 방법 완전탐색으로 모든 경우를 확인합니다. 다만 다른 채널을 경유해서 도달하는 경우, 해당 채널이 500000 이상으로 넘어갈 수 있다는 점을 고려해야합니다. ","date":"2021-11-06","objectID":"/boj-1107/:1:0","tags":["algorithm","cpp"],"title":"BOJ 1107 해설 C++","uri":"/boj-1107/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define endl '\\\\n' using namespace std; #define SUBMIT int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); #ifndef SUBMIT (void)!freopen(\"input.txt\", \"r\", stdin); cout \u003c\u003c \"# From the test case\" \u003c\u003c endl; #endif int target; cin \u003e\u003e target; int n; cin \u003e\u003e n; char c; string disabled; for(int i = 0; i \u003c n; ++i) { cin \u003e\u003e c; disabled.push_back(c); } int answer = abs(target - 100); for(int i = 0; i \u003c 1000000; ++i) { bool is_possible = true; for(int j = 0; j \u003c disabled.size(); ++j) { if(to_string(i).find(disabled[j]) != string::npos) { is_possible = false; break; } } if(!is_possible) continue; answer = min(answer, abs(i - target) + (int)to_string(i).size()); } cout \u003c\u003c answer \u003c\u003c endl; return 0; } ","date":"2021-11-06","objectID":"/boj-1107/:2:0","tags":["algorithm","cpp"],"title":"BOJ 1107 해설 C++","uri":"/boj-1107/"},{"categories":null,"content":"7662번: 이중 우선순위 큐 ","date":"2021-11-05","objectID":"/boj-7662/:0:0","tags":["algorithm","cpp"],"title":"BOJ 7662 해설 C++","uri":"/boj-7662/"},{"categories":null,"content":"접근 방법 두개의 우선순위 큐를 사용하는 풀이도 있지만, 우선순위 큐는 가장 위에 있는 값만 지울 수 있어 유연하지 못합니다. 그래서 이진 탐색 트리로 구현된 multiset을 사용하였습니다. C++의 multiset은 반복자를 활용해 삭제연산을 할 수 있습니다. ","date":"2021-11-05","objectID":"/boj-7662/:1:0","tags":["algorithm","cpp"],"title":"BOJ 7662 해설 C++","uri":"/boj-7662/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define endl '\\\\n' using namespace std; #define SUBMIT int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); #ifndef SUBMIT (void)!freopen(\"input.txt\", \"r\", stdin); cout \u003c\u003c \"# From the test case\" \u003c\u003c endl; #endif int T; cin \u003e\u003e T; while(T--) { multiset\u003cint\u003e ms; int N; cin \u003e\u003e N; char c; int value; for(int i = 0; i \u003c N; ++i) { cin \u003e\u003e c \u003e\u003e value; if(c == 'I') { ms.insert(value); continue; } if(c == 'D' \u0026\u0026 value == 1) { if(!ms.empty()) ms.erase(prev(ms.end())); continue; } if(c == 'D' \u0026\u0026 value == -1) { if(!ms.empty()) ms.erase(ms.begin()); continue; } } if(ms.empty()) cout \u003c\u003c \"EMPTY\" \u003c\u003c endl; else cout \u003c\u003c *ms.rbegin() \u003c\u003c ' ' \u003c\u003c *ms.begin() \u003c\u003c endl; } return 0; } ","date":"2021-11-05","objectID":"/boj-7662/:2:0","tags":["algorithm","cpp"],"title":"BOJ 7662 해설 C++","uri":"/boj-7662/"},{"categories":null,"content":"2805번: 나무 자르기 ","date":"2021-10-12","objectID":"/boj-2805/:0:0","tags":["algorithm","cpp"],"title":"BOJ 2805 해설 C++","uri":"/boj-2805/"},{"categories":null,"content":"접근 방법 나무의 최대 갯수가 1,000,000개 이므로 $O(N \\log M)$로 해결할 수 있습니다. 우선 0 부터 가장 높은 나무의 높이 사이의 범위를 이분탐색 합니다. 모든 탐색에서 mid 값으로 모든 나무를 잘랐을 때의 합을 타겟이 되는 M 값과 비교하여 이분 탐색을 진행해 주시면 되겠습니다. ","date":"2021-10-12","objectID":"/boj-2805/:1:0","tags":["algorithm","cpp"],"title":"BOJ 2805 해설 C++","uri":"/boj-2805/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define endl '\\\\n' #define fi first #define se second typedef long long ll; typedef unsigned long long ull; using namespace std; #define SUBMIT int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); #ifndef SUBMIT (void)!freopen(\"input.txt\", \"r\", stdin); cout \u003c\u003c \"# From the test case\" \u003c\u003c endl; #endif int N, M; cin \u003e\u003e N \u003e\u003e M; int _max; vector\u003cint\u003e v(N); for(int i = 0; i \u003c N; ++i) { cin \u003e\u003e v[i]; _max = _max \u003c v[i] ? v[i] : _max; } int ans = 0; int left = 0, right = _max, mid; while(left \u003c= right) { mid = (left + right) / 2; ll sum = 0; for(int i = 0; i \u003c N; ++i) sum += max(v[i] - mid, 0); if(sum \u003e= M) ans = mid; if(sum \u003c M) right = mid - 1; else left = mid + 1; } cout \u003c\u003c ans; return 0; } ","date":"2021-10-12","objectID":"/boj-2805/:2:0","tags":["algorithm","cpp"],"title":"BOJ 2805 해설 C++","uri":"/boj-2805/"},{"categories":null,"content":"15829번: Hashing ","date":"2021-10-12","objectID":"/boj-15829/:0:0","tags":["algorithm","cpp"],"title":"BOJ 15829 해설 C++","uri":"/boj-15829/"},{"categories":null,"content":"접근 방법 모듈로 연산의 성질을 이용하여 매 연산마다 모듈로를 취해 계산해줍니다. 모듈로 연산은 나눗셈을 제외한 연산에 대해 다음과 같은 특성을 가집니다. $(a + b)\\mod n = (a \\mod n + b \\mod n) \\mod n$ $(a - b)\\mod n = (a \\mod n - b \\mod n) \\mod n$ $(a * b)\\mod n = (a \\mod n * b \\mod n) \\mod n$ (A + B) % M = ((A % M) + (B % M)) % M (A * B) % M = ((A % M) * (B % M)) % M (A - B) % M = ((A % M) - (B % M)) % M ","date":"2021-10-12","objectID":"/boj-15829/:1:0","tags":["algorithm","cpp"],"title":"BOJ 15829 해설 C++","uri":"/boj-15829/"},{"categories":null,"content":"코드 #include \u003cbits/stdc++.h\u003e #define endl '\\\\n' #define fi first #define se second typedef long long ll; typedef unsigned long long ull; using namespace std; #define SUBMIT int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); #ifndef SUBMIT (void)!freopen(\"input.txt\", \"r\", stdin); cout \u003c\u003c \"# From the test case\" \u003c\u003c endl; #endif int M = 1234567891; int r = 31; int l; string s; cin \u003e\u003e l \u003e\u003e s; ll base = 1; ll ans = 0; for(int i = 0; i \u003c l; ++i) { int num = s[i]-'a' + 1; ans = (ans % M + ((num % M) * (base % M)) % M) % M; base = ((base % M) * (r % M)) % M; } cout \u003c\u003c ans; return 0; } ","date":"2021-10-12","objectID":"/boj-15829/:2:0","tags":["algorithm","cpp"],"title":"BOJ 15829 해설 C++","uri":"/boj-15829/"},{"categories":null,"content":"1074번: Z ","date":"2021-10-11","objectID":"/boj-1074/:0:0","tags":["algorithm","cpp"],"title":"BOJ 1074 해설 C++","uri":"/boj-1074/"},{"categories":null,"content":"접근 방법 N의 범위가 $1 \\le N \\le 15$ 이므로 Brute forcing으로 푼다면 최대 연산 횟수가 10억을 넘어 시간을 초과하게 됩니다. 좌표 공간을 4등분 해서, 찾고자 하는 r, c 값을 포함하는 범위에 대해 재귀를 수행하는 방법으로 풀면 시간 내에 충분히 해결할 수 있습니다. ","date":"2021-10-11","objectID":"/boj-1074/:1:0","tags":["algorithm","cpp"],"title":"BOJ 1074 해설 C++","uri":"/boj-1074/"},{"categories":null,"content":"코드 #iclude \u003cbits/stdc++.h\u003e #define endl '\\\\n' #define fi first #define se second typedef long long ll; typedef unsigned long long ull; using namespace std; /* - GLOBAL VARIABLES ---------------------------- */ int N, cnt, r, c; int ans; /* ----------------------------------------------- */ /* - FUNCTIONS ----------------------------------- */ void find(int len, int r_base, int c_base) { if(r_base == r \u0026\u0026 c_base == c) { // 좌표 공간을 나누는 기준 점이 r, c와 같다면 해당 지점을 찾아낸 것이므로 // 값을 저장합니다. ans = cnt; } if(r \u003e= r_base \u0026\u0026 r \u003c r_base + len \u0026\u0026 c \u003e= c_base \u0026\u0026 c \u003c c_base + len) { // Z 모양을 그리며 수행해야 하므로, 함수 호출 순서도 답에 영향이 있습니다. find(len / 2, r_base, c_base); find(len / 2, r_base, c_base + len / 2); find(len / 2, r_base + len / 2, c_base); find(len / 2, r_base + len / 2, c_base + len / 2); } else cnt += len * len; // 만약 r, c 값이 범위에 포함되지 않는다면 해당 범위는 진행한 것으로 가정하고 // 해당 범위의 좌표 갯수(길이의 제곱)를 더해줍니다. return; } /* ----------------------------------------------- */ // #define SUBMIT int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin \u003e\u003e N \u003e\u003e r \u003e\u003e c; find(pow(2, N), 0, 0); cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2021-10-11","objectID":"/boj-1074/:2:0","tags":["algorithm","cpp"],"title":"BOJ 1074 해설 C++","uri":"/boj-1074/"},{"categories":null,"content":"Spring Boot App을 실행하는 여러가지 방법들에 대해 소개합니다. ","date":"2021-10-09","objectID":"/run-spring-boot/:0:0","tags":["spring-boot","java"],"title":"Spring boot App을 실행하는 방법들","uri":"/run-spring-boot/"},{"categories":null,"content":"IntelliJ를 활용한 실행 IntelliJ IDE 를 사용중이라면 버튼 클릭 한번으로 손쉽게 실행할 수 있습니다. VM Option에 새로운 포트를 입력해주면 다른 포트로 인스턴스를 한개 더 띄울 수 있습니다. -Dserver.port=8081 Maven을 활용하여 커맨드 라인에서 실행 ./mvnw spring-boot:run -Dspring-boot.run.jvaArguments='-Dserver.port=9003' 빌드를 하고 직접 실행시키는 방법 $ ./mvnw clean $ ./mvnw compile package $ java -jar -Dserver.port=9004 ./target/user-service-0.0.1-SNAPSHOT.jar applicaion.yml 에서 server.port=0을 할당하면 매 실행 마다 랜덤한 포트로 실행됩니다. ","date":"2021-10-09","objectID":"/run-spring-boot/:1:0","tags":["spring-boot","java"],"title":"Spring boot App을 실행하는 방법들","uri":"/run-spring-boot/"},{"categories":null,"content":"이번 포스트에서는 Java, Spring Boot 환경에서 Mockito 기반의 테스트 코드를 작성하는 방법에 대해서 알아보겠습니다. Github에서 샘플 프로젝트의 전체 코드를 확인할 수 있습니다. GitHub - xvzc/spring-test: spring test repo Mockito 기반의 단위 테스트 견고한 코딩을 하기위해서 테스트 코드 작성은 필수입니다. 아래는 Mockito 기반의 테스트 코드입니다. @ExtendWith(MockitoExtension.class) public class UserServiceTest { @InjectMocks private UserService userService; @Mock private UserRepository userRepository; @DisplayName(\"유저 생성\") @Test void addUser() { final UserDto.AddRequest dto = UserDto.AddRequest.builder() .username(\"username\") .password(\"PaSsWoRd!2!#\") .nickname(\"usernick\") .bio(\"hello world\") .email(\"user@email.com\") .build(); User user= dto.toEntity(); doReturn(user).when(userRepository).save(any(User.class)); assertThat(userService.addUser(dto), is(UserDto.Response.of(user))); } } Mocking이란 가상의 객체를 생성해 스프링 컨텍스트를 실행하지 않고 테스트하는 환경을 의미합니다. 위 코드에서doReturn(user).when(userRepository).save(any(User.class));은 userRepository의 구현체를 사용하지 않고 save() 메서드의 리턴 값을 가정한다는 의미입니다. 이러한 방식을 사용하는 이유는 Service 로직을 테스트 하는 경우에 userRepository의 정상 동작 여부는 상관이 없기 때문입니다. 데이터베이스 연결을 맺지 않고 userRepository가 정상적으로 동작한다는 가정하에 진행한다면 테스트 과정이 경량화 된다는 장점이 있습니다. 패키지 목록 아래는 위와 같은 테스트 코드 작성을 위한 패키지 import 목록입니다. /** Essential imports for Unit tests Start */ import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.junit.jupiter.MockitoExtension; import static org.junit.Assert.*; import static org.mockito.ArgumentMatchers.*; import static org.mockito.Mockito.*; import static org.hamcrest.CoreMatchers.is; /** Essential imports for Unit tests End */ ","date":"2021-10-08","objectID":"/spring-boot-mockito/:0:0","tags":["spring-boot","java"],"title":"Spring Boot 가이드: Mockito 기반의 테스트 코드","uri":"/spring-boot-mockito/"},{"categories":null,"content":"이번 포스트에서는 Spring Boot 에서 예외처리를 하는 방법에 대해서 알아보겠습니다. Github에서 샘플 프로젝트의 전체 코드를 확인할 수 있습니다. GitHub - xvzc/spring-test: spring test repo Controller Advice 아래 코드는 서비스 레이어에서 발생하는 모든 예외를 처리하는 GlobalExceptionHandler 입니다. 개발자가 처리하지 못한 예외가 발생하는 경우, Exception 객체의 핸들러가 동작합니다. 이상적인 ****목표는 가능한 모든 예외를 핸들링 하여 internal server error를 응답하지 않는 것입니다. @Slf4j @RestControllerAdvice public class GlobalExceptionHandler { /** Custom Exceptions START */ // 자원을 찾을 수 없는 경우 @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(ResourceNotFoundException.class) protected ErrorResponse handleResourceNotFoundException(ResourceNotFoundException e) { log.error(\"handleMethodArgumentNotValidException\", e); return ErrorResponse.of(BasicError.of(e.errorCode)); } // Unique @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(AlreadyExistsException.class) protected ErrorResponse handleAlreadyExistsException(AlreadyExistsException e) { log.error(\"handleAlreadyExistsException\", e); return ErrorResponse.of(BasicError.of(e.errorCode)); } /** Custom Exceptions END*/ /** Built in Exceptions START */ // Bean Validation 실패 @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(MethodArgumentNotValidException.class) protected ErrorResponse handleMethodArgumentNotValidException(MethodArgumentNotValidException e) { ... } // Bean Validation 실패 @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(DataIntegrityViolationException.class) protected ErrorResponse handleDataIntegrityViolationException(DataIntegrityViolationException e) { ... } ... // 나머지 모든 예외들 @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(Exception.class) protected ErrorResponse handleException(Exception e) { log.error(\"handleEntityNotFoundException\", e); return ErrorResponse.of(BasicError.of(ErrorCode.INTERNAL_SERVER_ERROR)); } /** Built in Exceptions END */ } ErrorCode ErrorCode 클래스는 에러 메시지와 코드를 정의합니다. @JsonFormat(shape = JsonFormat.Shape.OBJECT) public enum ErrorCode { // GLOBAL INTERNAL_SERVER_ERROR(500, \"G-000\", \"Server Error\"), INVALID_INPUT_VALUE(400, \"G-001\", \" Invalid Input Value\"), METHOD_NOT_ALLOWED(405, \"G-002\", \" Method not allowed\"), INVALID_TYPE_VALUE(400, \"G-003\", \" Invalid Type Value\"), ACCESS_DENIED(403, \"G-004\", \"Access is Denied\"), // User EMAIL_DUPLICATION(400, \"USER-001\", \"Email already exists\"), LOGIN_FAILED(400, \"USER-002\", \"Login failed\"), USER_NOT_FOUND(404, \"USER-003\", \"User not found\"), USER_DUPLICATION(400, \"USER-004\", \"User Already Exists\") ; private final String code; private final String message; private int status; ErrorCode(final int status, final String code, final String message) { this.status = status; this.message = message; this.code = code; } public String getMessage() { return this.message; } public String getCode() { return code; } public int getStatus() { return status; } } 이런 방식을 사용하게 되면 UserNotFoundException, GrabNotFoundException등을 다음과 같이 처리할 수 있습니다. User user = userRepository.findById(id) .orElseThrow(() -\u003e new ResourceNotFoundException(ErrorCode.USER_NOT_FOUND)); // OR Grab grab = grabRepository.findById(id) .orElseThrow(() -\u003e new ResourceNotFoundException(ErrorCode.GRAB_NOT_FOUND)); ErrorResponse 효율적인 에러 처리를 위해 예외 응답을 통일합니다. @Getter public class ErrorResponse { Object data = null; BasicError error; private ErrorResponse(BasicError error) { this.data = null; this.error = error; } public static ErrorResponse of(BasicError error) { return new ErrorResponse(error); } } 에러 객체 아래는 에러 객체의 정의입니다. @Getter @NoArgsConstructor(access = AccessLevel.PROTECTED) public class BasicError { private String message; private int status; private List\u003cFieldError\u003e fields; private String code; private BasicError(final ErrorCode code, final List\u003cFieldError\u003e fields) { this.message = code.getMessage(); this.status = code.getStatus(); this.fields = fields; this.code = code.getCode(); } private BasicError(final ErrorCode code) { this.message = code.getMessage(); this.status = code.getStatus(); this.code = code.getCode(); this.fields = new ArrayList\u003c\u003e(); } public s","date":"2021-10-07","objectID":"/spring-boot-exception/:0:0","tags":["spring-boot","java"],"title":"Spring Boot 가이드: 예외 처리","uri":"/spring-boot-exception/"},{"categories":null,"content":"이번 포스트에서는 Spring Boot에서 값을 검증하는 방식에 대해 알아보겠습니다. Github에서 샘플 프로젝트의 전체 코드를 확인할 수 있습니다. GitHub - xvzc/spring-test: spring test repo 값 검증의 방식 값 검증에 주로 사용되는 Bean Validation에는 크게 두가지 방식이 있습니다. 요청 Dto 검증 요청 Dto 검증은 Controller에 요청된 RequestDto를 검증하는 방식입니다. 이 방식은 Controller에서 Service로 값을 넘겨주기 직전에 값을 검증합니다. @PostMapping(\"\") public UnitResponse\u003cUserDto.Response\u003e addUser(@Valid @RequestBody final UserDto.AddRequest dto) { return UnitResponse.of(userService.addUser(dto)); } 위와 같이 @Valid 애너테이션을 사용하면 Dto에 정의된 Validation annotaion을 참조하여 값을 검증합니다. 아래는 UserDto.AddRequest의 예시입니다. ... // 생략 public static class AddRequest { private String username; @Size(min = 6, max = 20) ... // 생략 @Email private String email; } 위에 보이는 것 처럼 @Size , @Email 애너테이션에 따라 값이 검증되며 조건에 맞지 않는 경우에는 예외가 발생하게됩니다. Dto 값 검증에서 발생한 예외는 필드 정보 등이 포함되어있어 에러 응답에 포함시켜서 응답할 수 있습니다. 발생한 예외는 GlobalExceptionHandler에서 처리됩니다. 엔티티 컬럼 검증 엔티티 컬럼 검증 방식은 엔티티 객체에 값을 대입할 때 수행됩니다. 다음은 User 클래스의 예시입니다. @Entity @Table(name = \"USERS\") @Getter @NoArgsConstructor(access = AccessLevel.PROTECTED) @EqualsAndHashCode public class User { ... // 생략 @Size(min = 6, max = 12) @Column(nullable = false, unique = true, length = 30) private String username; @Valid @Embedded private Password password; ... // 생략 @Valid @Embedded private Email email; /** * 만약 컬럼명이 Email 클래스에 정의된 것과 다르다면 * @AttributeOverride(name=\"value\", column=@Column(name=\"mail\"))로 덮어쓰기 가능 */ ... // 생략 } 엔티티 값 검증에 실패하면 ConstraintViolationException 이 발생합니다. 해당 예외는 엔티티 레벨에서 발생한 예외이므로 필드 정보가 따로 포함되어있지 않습니다. @Emebeded 컬럼의 경우 부모 엔티티에 @Valid 애너테이션을 사용해야만 검증이 수행됩니다. 아래는 Password 클래스의 예시 입니다. @Embeddable @Getter @EqualsAndHashCode @NoArgsConstructor(access = AccessLevel.PROTECTED) public class Password { @Size(min = 6, max = 20) @Column(name = \"password\", nullable = false, unique = true) private String value; @Builder protected Password(String value) { this.value = value; } public static Password of(String password) { return new Password(password); } } ","date":"2021-10-06","objectID":"/spring-boot-validation/:0:0","tags":["spring-boot","java"],"title":"Spring Boot 가이드: 값 검증","uri":"/spring-boot-validation/"},{"categories":null,"content":"이번 포스트에서는 Spring Boot에서 DTO의 사용법에 대해 알아보겠습니다. Github에서 샘플 프로젝트의 전체 코드를 확인할 수 있습니다. GitHub - xvzc/spring-test: spring test repo 요청 DTO 요청과 응답에 관련된 DTO의 경우, 메인 DTO 클래스의 서브 클래스로 정의하면 DTO 클래스들을 조금 더 깔끔하게 관리할 수 있습니다. Post 요청의 DTO는 추가적으로 DTO를 Entity로 변환하는 로직을 toEntity() 메서드로 감싸주면 더욱 보기좋은 코드를 작성할 수 있습니다. Mockito 기반의 Unit Test를 진행할 때 Equals를 사용해서 Assertion을 하는 경우가 많기 때문에 equals()와 hashcode()를 오버라이드 합니다. package com.example.project.domain.user.dto; import com.example.project.domain.user.entity.Email; import com.example.project.domain.user.entity.User; import lombok.*; public class UserDto { @Getter @Builder @EqualsAndHashCode public static class AddRequest { private String username; private String password; private String nickname; private String bio; private String email; public User toEntity() { return User.builder() .username(username) .password(password) .nickname(nickname) .bio(bio) .email(Email.of(email)) .build(); } } ... // 생략 } 응답 DTO 응답 DTO의 경우 엔티티를 인자로 받아 응답 객체로 반환하는 of() 메서드를 구현하면 서비스 레이어에서 더욱 보기좋은 코드를 작성할 수 있습니다. package com.example.project.domain.user.dto; import com.example.project.domain.user.entity.Email; import com.example.project.domain.user.entity.User; import lombok.*; public class UserDto { ... // 생략 @Getter @Builder @EqualsAndHashCode public static class Response { private String username; private String nickname; private String bio; private String email; public static Response of(final User user) { return Response.builder() .username(user.getUsername()) .nickname(user.getNickname()) .bio(user.getBio()) .email(user.getEmail().getValue()) .build(); } } } ","date":"2021-10-05","objectID":"/spring-boot-dto/:0:0","tags":["spring-boot","java"],"title":"Spring Boot 가이드: DTO","uri":"/spring-boot-dto/"},{"categories":null,"content":"이번 포스트에서는 Java Builder Pattern과 그 사용법에 대해서 알아보겠습니다. Github에서 샘플 프로젝트의 전체 코드를 확인할 수 있습니다. GitHub - xvzc/spring-test: spring test repo 생성자 사용의 단점 @Getter @Builder public class Person { String name; String city; int age; } 위와 같은 Person 클래스의 객체를 생성할 때 생성자를 사용한다면 다음과 같습니다. new Person(\"Jerry\", \"Seoul\", 29); 이 방식은 어떤 값이 어느 변수에 들어가는지 직관적으로 확인할 수 없다는 단점이 있습니다. 빌더 패턴 다음과 같이 빌더 패턴을 사용한다면 코드를 훨씬 쉽게 이해할 수 있습니다. Person person = new Person() .Builder() .name(\"Jerry\") .city(\"Seoul\") .age(29) .build(); 물론 Setter를 사용하는 방법도 있지만 멀티스레드 환경에서 동시성과 관련된 문제가 발생할 수 있기 때문에 빌더 패턴을 사용하는 것이 더욱 안전합니다. ","date":"2021-10-04","objectID":"/java-builder-pattern/:0:0","tags":["java"],"title":"Spring Boot 가이드: Java Builder Pattern","uri":"/java-builder-pattern/"},{"categories":null,"content":"이번 포스트에서는 Spring Boot에서 Service의 사용법에 대해 알아보겠습니다.. Github에서 샘플 프로젝트의 전체 코드를 확인할 수 있습니다. GitHub - xvzc/spring-test: spring test repo 객체 지향적 개발 도메인과 관련된 로직은 최대한 도메인 영역에 숨기는 것이 좋습니다. @Transactional public UserDto.Response updateUser(final UserDto.UpdateRequest dto, final Long id) { User user = userRepository.findById(id) .orElseThrow(() -\u003e new ResourceNotFoundException(ErrorCode.USER_NOT_FOUND)); user.update(dto); // 엔티티에 직접 정의한 메서드 return UserDto.Response.of(user); } Interface 의존성 주입 방식의 개선 방안 기존 Interface 의존성 주입 방식의 경우 메서드를 변경할 때 인터페이스와 구현체를 둘다 바꿔야 한다는 번거로움이 있습니다. 단일 서비스 인터페이스에 하나의 구현체만 존재한다면, 인터페이스 의존성 주입방식을 사용하지 않습니다. 다형성을 활용해야하는 상황이 생긴다면 해당 기능만 인터페이스로 분리하는 것도 좋은 아이디어가 될 수 있습니다. @Service @AllArgsConstructor public class UserService { ... public UserDto.Response getUser(final Long id) { User user = userRepository.findById(id) .orElseThrow(() -\u003e new ResourceNotFoundException(ErrorCode.USER_NOT_FOUND)); return UserDto.Response.of(user); } ... } ","date":"2021-10-03","objectID":"/spring-boot-service/:0:0","tags":["spring-boot","java"],"title":"Spring Boot 가이드: Service","uri":"/spring-boot-service/"},{"categories":null,"content":"이번 포스트에서는 Spring Boot에서 Controller의 사용법에 대해 알아보겠습니다. Github에서 샘플 프로젝트의 전체 코드를 확인할 수 있습니다. GitHub - xvzc/spring-test: spring test repo 요청 Path variable에 포함되지 않는 나머지 Json 데이터는 RequestBody로 받을 수 있습니다. @AllArgsConstructor @RestController @RequestMapping(\"/users\") public class UserController { @PutMapping(\"/{id}\") public SingleResponse updateUser(@RequestBody final UserDto.UpdateRequest dto, @PathVariable final Long id) { ... } } 전체 코드 컨트롤러는 특별한 경우가 아니라면 한 두줄 이내로 작성하는 것이 좋습니다. @AllArgsConstructor @RestController @RequestMapping(\"/users\") public class UserController { UserService userService; @GetMapping(\"{id}\") public UnitResponse\u003cUserDto.Response\u003e getUser(@PathVariable final Long id) { return UnitResponse.of(userService.getUser(id)); } @GetMapping(\"\") public ListResponse\u003cUserDto.Response\u003e getUserList() { return ListResponse.of(userService.getUserList()); } @PostMapping(\"\") public UnitResponse\u003cUserDto.Response\u003e addUser(@RequestBody final UserDto.AddRequest dto) { return UnitResponse.of(userService.addUser(dto)); } @PutMapping(\"/{id}\") public UnitResponse\u003cUserDto.Response\u003e updateUser( @RequestBody final UserDto.UpdateRequest dto, @PathVariable final Long id ) { return UnitResponse.of(userService.updateUser(dto, id)); } } ","date":"2021-10-02","objectID":"/spring-boot-controller/:0:0","tags":["spring-boot","java"],"title":"Spring Boot 가이드: Controller","uri":"/spring-boot-controller/"},{"categories":null,"content":"이번 포스트에서는 Spring Boot에서 Entity의 간단한 사용법에 대해서 알아보겠습니다. Github에서 샘플 프로젝트의 전체 코드를 확인할 수 있습니다. GitHub - xvzc/spring-test: spring test repo Sample 다음은 샘플 엔티티 USER의 코드입니다. @Entity @Table(name = \"USER\") @Getter @NoArgsConstructor(access = AccessLevel.PROTECTED) @EqualsAndHashCode public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true, length = 30) private String username; @Valid @Embedded private Password password; @Column(nullable = false, unique = true, length = 30) private String nickname; @Column(nullable = false, length = 191) private String bio; @Valid @Embedded private Email email; /** * 만약 컬럼명이 Email 클래스에 정의된 것과 다르다면 * @AttributeOverride(name=\"value\", column=@Column(name=\"mail\"))로 덮어쓰기 가능 */ @CreatedDate private LocalDateTime created; ... // 생략 } Password 의 경우 해당 컬럼만의 특정한 기능이 필요합니다. 예를들면 암호화, 해싱, 단일 컬럼 업데이트 등이 이에 속합니다. 이러한 경우 새로운 클래스를 정의해서 Embeded 컬럼으로 사용하는 것이 좋습니다. JPA Auditing JPA Auditing을 사용하면 생성 및 수정 날짜를 직접 입력하지 않고도 자동으로 최신화 시킬 수 있습니다. 아래는 샘플 엔티티인 Post 클래스에서 JPA Auditing을 사용한 예시입니다. @Entity @Table(name = \"POST\") public class Post { ... // 생략 @CreatedDate private LocalDateTime created; @LastModifiedDate private LocalDateTime modified; @PrePersist public void onPrePersist(){ this.created = LocalDateTime.parse( LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\")), DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\") ); this.modified = this.created; } @PreUpdate public void onPreUpdate(){ this.modified= LocalDateTime .parse( LocalDateTime.now() .format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\")), DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\") ); } } ","date":"2021-10-01","objectID":"/springboot-jpa-entity/:0:0","tags":["java","spring-boot"],"title":"Spring Boot 가이드: Entity","uri":"/springboot-jpa-entity/"}]